<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libft900: include/ft900_usbd_dfu.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="brtlogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">libft900<span id="projectnumber">&#160;2.6.0</span>
   </div>
   <div id="projectbrief">A hardware abstraction library for the FT9xx</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle"><div class="title">ft900_usbd_dfu.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>DFU device for USB device stack API.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab0712226291dca0bd73a7f37d4055a1b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd__dfu_8h.html#ab0712226291dca0bd73a7f37d4055a1b">USBD_DFU_MAX_BLOCK_SIZE</a>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:ab0712226291dca0bd73a7f37d4055a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum block size for a packet of data from the host in a DFU_DNLOAD request. A packet sent to the device for programming or a request for data frm the Flash cannot ever cross a page boundary. The maximum block size is therefore the page size. All requests for data must be entirely within a page.  <a href="ft900__usbd__dfu_8h.html#ab0712226291dca0bd73a7f37d4055a1b">More...</a><br /></td></tr>
<tr class="separator:ab0712226291dca0bd73a7f37d4055a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517812dd8c9982cd68ccde994ecfbc13"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd__dfu_8h.html#a517812dd8c9982cd68ccde994ecfbc13">USBD_DFU_TIMEOUT</a>&#160;&#160;&#160;0x2000</td></tr>
<tr class="memdesc:a517812dd8c9982cd68ccde994ecfbc13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suggested timeout for DFU downloads.  <a href="ft900__usbd__dfu_8h.html#a517812dd8c9982cd68ccde994ecfbc13">More...</a><br /></td></tr>
<tr class="separator:a517812dd8c9982cd68ccde994ecfbc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">USBD_DFU_ATTRIBUTES</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrp8b7f6af44b652a177cfa7e39c3e12052"></a>Determines the parts of the DFU specification which are supported by this library. These can be a combination of: USB_DFU_BMATTRIBUTES_CANDNLOAD - Firmware download (program device). USB_DFU_BMATTRIBUTES_CANUPLOAD - Firmware upload (read device). USB_DFU_BMATTRIBUTES_WILLDETACH - Device perform a detach and attach sequence to change into DFU mode. If this is not supported then the host must reset the USB after a detach request. This will cause the device to reset and enter DFU mode. USB_DFU_BMATTRIBUTES_MANIFESTATIONTOLERANT - Continue to allow DFU requests after a download has completed. This is not turned on to force the default behaviour to be that the device will run any new firmware after it is downloaded. Un-defining attributes will remove support for that feature from the library. Firmware may not need all the features and can disable them in the configuration descriptor. </p>
</td></tr>
<tr class="memitem:ad71ee06db20b97d1a65bf44df152af4b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd__dfu_8h.html#ad71ee06db20b97d1a65bf44df152af4b">USBD_DFU_ATTRIBUTES</a></td></tr>
<tr class="separator:ad71ee06db20b97d1a65bf44df152af4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd4be558137bb73264786fd1a11bfea"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd__dfu_8h.html#a0bd4be558137bb73264786fd1a11bfea">USBD_DFU_is_runtime</a> (void)</td></tr>
<tr class="memdesc:a0bd4be558137bb73264786fd1a11bfea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine current mode of DFU.  <a href="ft900__usbd__dfu_8h.html#a0bd4be558137bb73264786fd1a11bfea">More...</a><br /></td></tr>
<tr class="separator:a0bd4be558137bb73264786fd1a11bfea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ebaf0190d7453746cae0fde51830f6"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd__dfu_8h.html#a95ebaf0190d7453746cae0fde51830f6">USBD_DFU_is_wait_reset</a> (void)</td></tr>
<tr class="memdesc:a95ebaf0190d7453746cae0fde51830f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if DFU waiting to reset.  <a href="ft900__usbd__dfu_8h.html#a95ebaf0190d7453746cae0fde51830f6">More...</a><br /></td></tr>
<tr class="separator:a95ebaf0190d7453746cae0fde51830f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366fabbe7800e423e9de8de729f47ab4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd__dfu_8h.html#a366fabbe7800e423e9de8de729f47ab4">USBD_DFU_set_dfumode</a> (void)</td></tr>
<tr class="memdesc:a366fabbe7800e423e9de8de729f47ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force a transition into DFU mode.  <a href="ft900__usbd__dfu_8h.html#a366fabbe7800e423e9de8de729f47ab4">More...</a><br /></td></tr>
<tr class="separator:a366fabbe7800e423e9de8de729f47ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf983cfd9b47cca8cb78252ca302a579"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd__dfu_8h.html#aaf983cfd9b47cca8cb78252ca302a579">USBD_DFU_class_req_detach</a> (uint16_t timeout)</td></tr>
<tr class="memdesc:aaf983cfd9b47cca8cb78252ca302a579"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB class request handler for DFU_DETACH.  <a href="ft900__usbd__dfu_8h.html#aaf983cfd9b47cca8cb78252ca302a579">More...</a><br /></td></tr>
<tr class="separator:aaf983cfd9b47cca8cb78252ca302a579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055be3693f659442ca9d553e6802a167"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd__dfu_8h.html#a055be3693f659442ca9d553e6802a167">USBD_DFU_class_req_download</a> (uint32_t block, uint16_t dataLength)</td></tr>
<tr class="memdesc:a055be3693f659442ca9d553e6802a167"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB class request handler for DFU_DNLOAD.  <a href="ft900__usbd__dfu_8h.html#a055be3693f659442ca9d553e6802a167">More...</a><br /></td></tr>
<tr class="separator:a055be3693f659442ca9d553e6802a167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35c3b4375e646d4c7ec0d45526b1a18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd__dfu_8h.html#af35c3b4375e646d4c7ec0d45526b1a18">USBD_DFU_class_req_upload</a> (uint32_t block, uint16_t dataLength)</td></tr>
<tr class="memdesc:af35c3b4375e646d4c7ec0d45526b1a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB class request handler for DFU_UPLOAD.  <a href="ft900__usbd__dfu_8h.html#af35c3b4375e646d4c7ec0d45526b1a18">More...</a><br /></td></tr>
<tr class="separator:af35c3b4375e646d4c7ec0d45526b1a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908ceb91590fa0b009a4374633c45eb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd__dfu_8h.html#a908ceb91590fa0b009a4374633c45eb0">USBD_DFU_class_req_getstatus</a> (uint16_t requestLen)</td></tr>
<tr class="memdesc:a908ceb91590fa0b009a4374633c45eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB class request handler for DFU_GETSTATUS.  <a href="ft900__usbd__dfu_8h.html#a908ceb91590fa0b009a4374633c45eb0">More...</a><br /></td></tr>
<tr class="separator:a908ceb91590fa0b009a4374633c45eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089aea68e7d1dbe6e518303eb9d97a5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd__dfu_8h.html#a089aea68e7d1dbe6e518303eb9d97a5c">USBD_DFU_class_req_clrstatus</a> (void)</td></tr>
<tr class="memdesc:a089aea68e7d1dbe6e518303eb9d97a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB class request handler for DFU_CLRSTATUS.  <a href="ft900__usbd__dfu_8h.html#a089aea68e7d1dbe6e518303eb9d97a5c">More...</a><br /></td></tr>
<tr class="separator:a089aea68e7d1dbe6e518303eb9d97a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7bb320df5eb7d97e86c23d1ba430ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd__dfu_8h.html#abc7bb320df5eb7d97e86c23d1ba430ca">USBD_DFU_class_req_abort</a> (void)</td></tr>
<tr class="memdesc:abc7bb320df5eb7d97e86c23d1ba430ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB class request handler for DFU_ABORT.  <a href="ft900__usbd__dfu_8h.html#abc7bb320df5eb7d97e86c23d1ba430ca">More...</a><br /></td></tr>
<tr class="separator:abc7bb320df5eb7d97e86c23d1ba430ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc1d27eb30ac91df0de7c9d69ab9d96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd__dfu_8h.html#a6bc1d27eb30ac91df0de7c9d69ab9d96">USBD_DFU_class_req_getstate</a> (uint16_t requestLen)</td></tr>
<tr class="memdesc:a6bc1d27eb30ac91df0de7c9d69ab9d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB class request handler for DFU_GETSTATE.  <a href="ft900__usbd__dfu_8h.html#a6bc1d27eb30ac91df0de7c9d69ab9d96">More...</a><br /></td></tr>
<tr class="separator:a6bc1d27eb30ac91df0de7c9d69ab9d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919ef4b764afb662a0b5c37ec9bbfc09"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd__dfu_8h.html#a919ef4b764afb662a0b5c37ec9bbfc09">USBD_DFU_reset</a> (void)</td></tr>
<tr class="memdesc:a919ef4b764afb662a0b5c37ec9bbfc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of USB reset state handler for DFU.  <a href="ft900__usbd__dfu_8h.html#a919ef4b764afb662a0b5c37ec9bbfc09">More...</a><br /></td></tr>
<tr class="separator:a919ef4b764afb662a0b5c37ec9bbfc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9a3610655fbc305e56d971906e0a1f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd__dfu_8h.html#a8e9a3610655fbc305e56d971906e0a1f">USBD_DFU_timer</a> (void)</td></tr>
<tr class="memdesc:a8e9a3610655fbc305e56d971906e0a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the detach_counter and adjusts state accordingly.  <a href="ft900__usbd__dfu_8h.html#a8e9a3610655fbc305e56d971906e0a1f">More...</a><br /></td></tr>
<tr class="separator:a8e9a3610655fbc305e56d971906e0a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >DFU device for USB device stack API. </p>
<p >API functions for USB Device DFU interfaces. These functions provide functionality required to communicate with a DFU application through the USB Device interface. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad71ee06db20b97d1a65bf44df152af4b" name="ad71ee06db20b97d1a65bf44df152af4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad71ee06db20b97d1a65bf44df152af4b">&#9670;&nbsp;</a></span>USBD_DFU_ATTRIBUTES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBD_DFU_ATTRIBUTES</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        (<a class="code hl_define" href="ft900__usb__dfu_8h.html#a971edecde35d07e5a68fa1985f269921">USB_DFU_BMATTRIBUTES_CANDNLOAD</a> |\</div>
<div class="line">        USB_DFU_BMATTRIBUTES_WILLDETACH |\</div>
<div class="line">        USB_DFU_BMATTRIBUTES_CANUPLOAD)</div>
<div class="ttc" id="aft900__usb__dfu_8h_html_a971edecde35d07e5a68fa1985f269921"><div class="ttname"><a href="ft900__usb__dfu_8h.html#a971edecde35d07e5a68fa1985f269921">USB_DFU_BMATTRIBUTES_CANDNLOAD</a></div><div class="ttdeci">#define USB_DFU_BMATTRIBUTES_CANDNLOAD</div><div class="ttdef"><b>Definition:</b> ft900_usb_dfu.h:209</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab0712226291dca0bd73a7f37d4055a1b" name="ab0712226291dca0bd73a7f37d4055a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0712226291dca0bd73a7f37d4055a1b">&#9670;&nbsp;</a></span>USBD_DFU_MAX_BLOCK_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBD_DFU_MAX_BLOCK_SIZE&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum block size for a packet of data from the host in a DFU_DNLOAD request. A packet sent to the device for programming or a request for data frm the Flash cannot ever cross a page boundary. The maximum block size is therefore the page size. All requests for data must be entirely within a page. </p>

</div>
</div>
<a id="a517812dd8c9982cd68ccde994ecfbc13" name="a517812dd8c9982cd68ccde994ecfbc13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517812dd8c9982cd68ccde994ecfbc13">&#9670;&nbsp;</a></span>USBD_DFU_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBD_DFU_TIMEOUT&#160;&#160;&#160;0x2000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suggested timeout for DFU downloads. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="abc7bb320df5eb7d97e86c23d1ba430ca" name="abc7bb320df5eb7d97e86c23d1ba430ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7bb320df5eb7d97e86c23d1ba430ca">&#9670;&nbsp;</a></span>USBD_DFU_class_req_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_DFU_class_req_abort </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB class request handler for DFU_ABORT. </p>
<p >Aborts transaction and resets the DFU state machine. </p>

</div>
</div>
<a id="a089aea68e7d1dbe6e518303eb9d97a5c" name="a089aea68e7d1dbe6e518303eb9d97a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089aea68e7d1dbe6e518303eb9d97a5c">&#9670;&nbsp;</a></span>USBD_DFU_class_req_clrstatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_DFU_class_req_clrstatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB class request handler for DFU_CLRSTATUS. </p>
<p >Clears an error state for the DFU state machine. </p>

</div>
</div>
<a id="aaf983cfd9b47cca8cb78252ca302a579" name="aaf983cfd9b47cca8cb78252ca302a579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf983cfd9b47cca8cb78252ca302a579">&#9670;&nbsp;</a></span>USBD_DFU_class_req_detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_DFU_class_req_detach </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB class request handler for DFU_DETACH. </p>
<p >Move the state machine to appDETACH state from appIDLE and initialise a timeout within which time the host should set a USB reset on the bus. An ACK packet is sent on the USB control IN endpoint to the host to acknowledge successful completion of this request. The bmAttributes value set in the USBD_DFU_ATTRIBUTES determines the actions that are taken upon a detach. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>- number of milliseconds timeout before reverting to appIDLE if no USB reset is forthcoming from the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a055be3693f659442ca9d553e6802a167" name="a055be3693f659442ca9d553e6802a167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055be3693f659442ca9d553e6802a167">&#9670;&nbsp;</a></span>USBD_DFU_class_req_download()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_DFU_class_req_download </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dataLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB class request handler for DFU_DNLOAD. </p>
<p >Receive blocks of firmware from the host on the control OUT endpoint and program these into the MTP. If the state machine is in the dfuIDLE state then move to dfuDNLOAD_IDLE state. If zero length data is received indicating the end of the firmware then move the state machine to dfuMANIFEST_WAIT_RESET. If an address or data length error are detected then move to the dfuERROR state. An ACK packet is sent on the USB control IN endpoint to the host to acknowledge successful completion of this request. If the bmAttributes value set in the USBD_DFU_ATTRIBUTES does not support download then this function will have no body. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>- Starting block number (address) of data to program. It is up to the calling program to make sure this is calculated correctly. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataLength</td><td>- Number of bytes to program. This can be between the control endpoint max packet size and DFU_MAX_BLOCK_SIZE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bc1d27eb30ac91df0de7c9d69ab9d96" name="a6bc1d27eb30ac91df0de7c9d69ab9d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc1d27eb30ac91df0de7c9d69ab9d96">&#9670;&nbsp;</a></span>USBD_DFU_class_req_getstate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_DFU_class_req_getstate </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>requestLen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB class request handler for DFU_GETSTATE. </p>
<p >Return a single byte to the host containing the current DFU state machine byte. The data is written via the control IN endpoint to the host. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">requestLen</td><td>- number of bytes requested by the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a908ceb91590fa0b009a4374633c45eb0" name="a908ceb91590fa0b009a4374633c45eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908ceb91590fa0b009a4374633c45eb0">&#9670;&nbsp;</a></span>USBD_DFU_class_req_getstatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_DFU_class_req_getstatus </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>requestLen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB class request handler for DFU_GETSTATUS. </p>
<p >Return a structure to the host containing the current DFU state machine and status bytes. These are used by the application on the host to work out whether any errors have occurred and what the status of the device is. The structure is written via the control IN endpoint to the host. The bmAttributes value set in the USBD_DFU_ATTRIBUTES determines the actions that are taken upon a GET_STATUS. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">requestLen</td><td>- number of bytes requested by the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af35c3b4375e646d4c7ec0d45526b1a18" name="af35c3b4375e646d4c7ec0d45526b1a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35c3b4375e646d4c7ec0d45526b1a18">&#9670;&nbsp;</a></span>USBD_DFU_class_req_upload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_DFU_class_req_upload </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dataLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB class request handler for DFU_UPLOAD. </p>
<p >Receive blocks of firmware from the Flash to the control IN endpoint. If the state machine is in the dfuIDLE state then move to dfuUPLOAD_IDLE state. If an address or data length error are detected then move to the dfuERROR state. An ACK packet is sent on the USB control IN endpoint to the host to acknowledge successful completion of this request. If the bmAttributes value set in the USBD_DFU_ATTRIBUTES does not support upload then this function will have no body. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>- Starting block number (address) of data to read. It is up to the calling program to make sure this is calculated correctly. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataLength</td><td>- Number of bytes to read. This can be between the control endpoint max packet size and DFU_MAX_BLOCK_SIZE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bd4be558137bb73264786fd1a11bfea" name="a0bd4be558137bb73264786fd1a11bfea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd4be558137bb73264786fd1a11bfea">&#9670;&nbsp;</a></span>USBD_DFU_is_runtime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBD_DFU_is_runtime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine current mode of DFU. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns non-zero if the DFU state is runtime mode. </dd></dl>

</div>
</div>
<a id="a95ebaf0190d7453746cae0fde51830f6" name="a95ebaf0190d7453746cae0fde51830f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ebaf0190d7453746cae0fde51830f6">&#9670;&nbsp;</a></span>USBD_DFU_is_wait_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBD_DFU_is_wait_reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if DFU waiting to reset. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns non-zero if the DFU state machine is in dfuMANIFEST-WAIT-RESET and is therefore waiting for a host reset or detach/attach sequence. If the bmAttributes value set in the USBD_DFU_ATTRIBUTES does support manifestation then this function should not be required. </dd></dl>

</div>
</div>
<a id="a919ef4b764afb662a0b5c37ec9bbfc09" name="a919ef4b764afb662a0b5c37ec9bbfc09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a919ef4b764afb662a0b5c37ec9bbfc09">&#9670;&nbsp;</a></span>USBD_DFU_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBD_DFU_reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of USB reset state handler for DFU. </p>
<p >Move Reset or advance the DFU state machine when a USB reset is encountered. This will change the state to dfuIDLE if it was in appDETACH state before. It will change to dfuERROR if a download was in progress. Otherwise it will return to appIDLE. Return a byte to the host indicating if the next state change of the DFU state machine byte requires code to be reloaded and run. i.e. a new program needs to be run. The bmAttributes value set in the USBD_DFU_ATTRIBUTES determines the actions that are taken upon a reset. </p><dl class="section return"><dt>Returns</dt><dd>status - non-zero if new program is to be run. </dd></dl>

</div>
</div>
<a id="a366fabbe7800e423e9de8de729f47ab4" name="a366fabbe7800e423e9de8de729f47ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366fabbe7800e423e9de8de729f47ab4">&#9670;&nbsp;</a></span>USBD_DFU_set_dfumode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_DFU_set_dfumode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force a transition into DFU mode. </p>

</div>
</div>
<a id="a8e9a3610655fbc305e56d971906e0a1f" name="a8e9a3610655fbc305e56d971906e0a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9a3610655fbc305e56d971906e0a1f">&#9670;&nbsp;</a></span>USBD_DFU_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBD_DFU_timer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrements the detach_counter and adjusts state accordingly. </p>
<p >If the state is appDETACH moves to dfuIDLE state if we have been in the appDETACH state for longer than the attach timeout specified by the DFU_DETACH request.</p>
<p >Note: This is run from INTERRUPT LEVEL as a handler for an ISR. The bmAttributes value set in the USBD_DFU_ATTRIBUTES determines the actions that are taken upon a timer event (i.e. may call a detach). </p><dl class="section return"><dt>Returns</dt><dd>Zero if timer running, non-zero if timer expired. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 7 2022 14:07:40 for libft900 by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
