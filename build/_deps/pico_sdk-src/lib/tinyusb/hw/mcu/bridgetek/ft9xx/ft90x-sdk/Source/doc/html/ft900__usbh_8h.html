<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libft900: include/ft900_usbh.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="brtlogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">libft900<span id="projectnumber">&#160;2.6.0</span>
   </div>
   <div id="projectbrief">A hardware abstraction library for the FT9xx</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle"><div class="title">ft900_usbh.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>USB host stack API.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_h__ctx.html">USBH_ctx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing configuration data for the USB EHCI controller, USBH memory space allocation, callback functions for USB events.  <a href="struct_u_s_b_h__ctx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_h__device__info.html">USBH_device_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing current information about a device.  <a href="struct_u_s_b_h__device__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_h__interface__info.html">USBH_interface_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing current information about an interface.  <a href="struct_u_s_b_h__interface__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_h__endpoint__info.html">USBH_endpoint_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a27681211c81718cc119c210a2289ae6a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a27681211c81718cc119c210a2289ae6a">ALIGN32</a>&#160;&#160;&#160;__attribute__ ((aligned(4)))</td></tr>
<tr class="separator:a27681211c81718cc119c210a2289ae6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Definitions for USB Host return values</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Set of return values from USB Host API calls. </p>
</div></td></tr>
<tr class="memitem:a5b3ea27703d8bb0c9d7d680d5e8cb7e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a5b3ea27703d8bb0c9d7d680d5e8cb7e8">USBH_OK</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="memdesc:a5b3ea27703d8bb0c9d7d680d5e8cb7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Success for USB Host function.  <a href="ft900__usbh_8h.html#a5b3ea27703d8bb0c9d7d680d5e8cb7e8">More...</a><br /></td></tr>
<tr class="separator:a5b3ea27703d8bb0c9d7d680d5e8cb7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ae447e613731a4e7506d6bd54594ff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#af2ae447e613731a4e7506d6bd54594ff">USBH_ENUM_NO_CHANGE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:af2ae447e613731a4e7506d6bd54594ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">No change in enumeration.  <a href="ft900__usbh_8h.html#af2ae447e613731a4e7506d6bd54594ff">More...</a><br /></td></tr>
<tr class="separator:af2ae447e613731a4e7506d6bd54594ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898c0c1e53622a51be70120acf3faf55"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a898c0c1e53622a51be70120acf3faf55">USBH_ENUM_PARTIAL</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a898c0c1e53622a51be70120acf3faf55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial enumeration only.  <a href="ft900__usbh_8h.html#a898c0c1e53622a51be70120acf3faf55">More...</a><br /></td></tr>
<tr class="separator:a898c0c1e53622a51be70120acf3faf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a40f7f491a9622c3ff39a0708e7b8c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#ab5a40f7f491a9622c3ff39a0708e7b8c">USBH_ERR_RESOURCES</a>&#160;&#160;&#160;-1</td></tr>
<tr class="memdesc:ab5a40f7f491a9622c3ff39a0708e7b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lack of resources to perform USB Host function.  <a href="ft900__usbh_8h.html#ab5a40f7f491a9622c3ff39a0708e7b8c">More...</a><br /></td></tr>
<tr class="separator:ab5a40f7f491a9622c3ff39a0708e7b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5548d70b0aaddb249786207f5fabb0d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#ad5548d70b0aaddb249786207f5fabb0d">USBH_ERR_USBERR</a>&#160;&#160;&#160;-2</td></tr>
<tr class="memdesc:ad5548d70b0aaddb249786207f5fabb0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Host controller completed and reported an error.  <a href="ft900__usbh_8h.html#ad5548d70b0aaddb249786207f5fabb0d">More...</a><br /></td></tr>
<tr class="separator:ad5548d70b0aaddb249786207f5fabb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e764217788432baaf4a538eb90951e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a3e764217788432baaf4a538eb90951e4">USBH_ERR_HOST_HALTED</a>&#160;&#160;&#160;-3</td></tr>
<tr class="memdesc:a3e764217788432baaf4a538eb90951e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Host controller halted.  <a href="ft900__usbh_8h.html#a3e764217788432baaf4a538eb90951e4">More...</a><br /></td></tr>
<tr class="separator:a3e764217788432baaf4a538eb90951e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3aee7c4bc1609107e0ae8835a06f68d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#ab3aee7c4bc1609107e0ae8835a06f68d">USBH_ERR_NOT_FOUND</a>&#160;&#160;&#160;-4</td></tr>
<tr class="memdesc:ab3aee7c4bc1609107e0ae8835a06f68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint, Device or Interface not found.  <a href="ft900__usbh_8h.html#ab3aee7c4bc1609107e0ae8835a06f68d">More...</a><br /></td></tr>
<tr class="separator:ab3aee7c4bc1609107e0ae8835a06f68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf2a00937bfcba7b2e40253e4db78ac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a3bf2a00937bfcba7b2e40253e4db78ac">USBH_ERR_REMOVED</a>&#160;&#160;&#160;-5</td></tr>
<tr class="memdesc:a3bf2a00937bfcba7b2e40253e4db78ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint, Device or Interface removed.  <a href="ft900__usbh_8h.html#a3bf2a00937bfcba7b2e40253e4db78ac">More...</a><br /></td></tr>
<tr class="separator:a3bf2a00937bfcba7b2e40253e4db78ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ab254b50a73670f6a1ed19e9888f4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#aa8ab254b50a73670f6a1ed19e9888f4d">USBH_ERR_STALLED</a>&#160;&#160;&#160;-6</td></tr>
<tr class="memdesc:aa8ab254b50a73670f6a1ed19e9888f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint stalled.  <a href="ft900__usbh_8h.html#aa8ab254b50a73670f6a1ed19e9888f4d">More...</a><br /></td></tr>
<tr class="separator:aa8ab254b50a73670f6a1ed19e9888f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d83e792a6f2bec208e925277e9057f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a00d83e792a6f2bec208e925277e9057f">USBH_ERR_TIMEOUT</a>&#160;&#160;&#160;-8</td></tr>
<tr class="memdesc:a00d83e792a6f2bec208e925277e9057f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint transaction timeout.  <a href="ft900__usbh_8h.html#a00d83e792a6f2bec208e925277e9057f">More...</a><br /></td></tr>
<tr class="separator:a00d83e792a6f2bec208e925277e9057f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7bee00fb9919eb80bd7329e3fcc682"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a1e7bee00fb9919eb80bd7329e3fcc682">USBH_ERR_PARAMETER</a>&#160;&#160;&#160;-15</td></tr>
<tr class="memdesc:a1e7bee00fb9919eb80bd7329e3fcc682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request parameter error.  <a href="ft900__usbh_8h.html#a1e7bee00fb9919eb80bd7329e3fcc682">More...</a><br /></td></tr>
<tr class="separator:a1e7bee00fb9919eb80bd7329e3fcc682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace38a3726a79569b481c917abdb5198e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#ace38a3726a79569b481c917abdb5198e">USBH_ERR_HALTED</a>&#160;&#160;&#160;-16</td></tr>
<tr class="memdesc:ace38a3726a79569b481c917abdb5198e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transaction completed with halted state.  <a href="ft900__usbh_8h.html#ace38a3726a79569b481c917abdb5198e">More...</a><br /></td></tr>
<tr class="separator:ace38a3726a79569b481c917abdb5198e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabac5dc6dca652af8534cceafd947163"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#aabac5dc6dca652af8534cceafd947163">USBH_ERR_DATA_BUF</a>&#160;&#160;&#160;-17</td></tr>
<tr class="memdesc:aabac5dc6dca652af8534cceafd947163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint data underun or overrun.  <a href="ft900__usbh_8h.html#aabac5dc6dca652af8534cceafd947163">More...</a><br /></td></tr>
<tr class="separator:aabac5dc6dca652af8534cceafd947163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f21082a5340c44e13f483efa4cf02f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#ae9f21082a5340c44e13f483efa4cf02f">USBH_ERR_BABBLE</a>&#160;&#160;&#160;-18</td></tr>
<tr class="memdesc:ae9f21082a5340c44e13f483efa4cf02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint data babble detected.  <a href="ft900__usbh_8h.html#ae9f21082a5340c44e13f483efa4cf02f">More...</a><br /></td></tr>
<tr class="separator:ae9f21082a5340c44e13f483efa4cf02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79db28d39407476c4ecebd5fb21f75f3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a79db28d39407476c4ecebd5fb21f75f3">USBH_ERR_XACTERR</a>&#160;&#160;&#160;-19</td></tr>
<tr class="memdesc:a79db28d39407476c4ecebd5fb21f75f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint data transaction error.  <a href="ft900__usbh_8h.html#a79db28d39407476c4ecebd5fb21f75f3">More...</a><br /></td></tr>
<tr class="separator:a79db28d39407476c4ecebd5fb21f75f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fc52aab3e65cdc4007b5a19cde00af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a45fc52aab3e65cdc4007b5a19cde00af">USBH_ERR_MISSED_MICROFRAME</a>&#160;&#160;&#160;-20</td></tr>
<tr class="memdesc:a45fc52aab3e65cdc4007b5a19cde00af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint data missed microframe.  <a href="ft900__usbh_8h.html#a45fc52aab3e65cdc4007b5a19cde00af">More...</a><br /></td></tr>
<tr class="separator:a45fc52aab3e65cdc4007b5a19cde00af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd8c02de4d7d17816ace26e6dd4acb1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#aacd8c02de4d7d17816ace26e6dd4acb1">USBH_ERR_SPLITX</a>&#160;&#160;&#160;-21</td></tr>
<tr class="memdesc:aacd8c02de4d7d17816ace26e6dd4acb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint split transaction state.  <a href="ft900__usbh_8h.html#aacd8c02de4d7d17816ace26e6dd4acb1">More...</a><br /></td></tr>
<tr class="separator:aacd8c02de4d7d17816ace26e6dd4acb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae221fe98bfd853a1a5f11b9aac1d0a65"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#ae221fe98bfd853a1a5f11b9aac1d0a65">USBH_ERR_PING_ERR</a>&#160;&#160;&#160;-22</td></tr>
<tr class="memdesc:ae221fe98bfd853a1a5f11b9aac1d0a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint ping state.  <a href="ft900__usbh_8h.html#ae221fe98bfd853a1a5f11b9aac1d0a65">More...</a><br /></td></tr>
<tr class="separator:ae221fe98bfd853a1a5f11b9aac1d0a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Device, Endpoint and Interface Handles.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Handles are used to pass devices, interfaces and endpoints to the application. </p>
</div></td></tr>
<tr class="memitem:aebfe5028b9b46387e02a1572b83fddec"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a></td></tr>
<tr class="memdesc:aebfe5028b9b46387e02a1572b83fddec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that is used to pass a handle to a device to the application. It is made up of a pointer to the device structure and a fairly unique value to detect enumeration changes and hence stale handles.  <a href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">More...</a><br /></td></tr>
<tr class="separator:aebfe5028b9b46387e02a1572b83fddec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccfed31ca31c08159ef593468abf47f"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a8ccfed31ca31c08159ef593468abf47f">USBH_interface_handle</a></td></tr>
<tr class="memdesc:a8ccfed31ca31c08159ef593468abf47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that is used to pass a handle to an interface to the application. It is made up of a pointer to the interface structure and a fairly unique value to detect enumeration changes and hence stale handles.  <a href="ft900__usbh_8h.html#a8ccfed31ca31c08159ef593468abf47f">More...</a><br /></td></tr>
<tr class="separator:a8ccfed31ca31c08159ef593468abf47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc30246a89dcc150be319f2178df101"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a></td></tr>
<tr class="memdesc:a6fc30246a89dcc150be319f2178df101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that is used to pass a handle to an endpoint to the application. It is made up of a pointer to the endpoint structure and a fairly unique value to detect enumeration changes and hence stale handles.  <a href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">More...</a><br /></td></tr>
<tr class="separator:a6fc30246a89dcc150be319f2178df101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af411e8ac30392cf70a4b0df5817befe4"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_u_s_b_h__ctx.html">USBH_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#af411e8ac30392cf70a4b0df5817befe4">USBH_ctx</a></td></tr>
<tr class="separator:af411e8ac30392cf70a4b0df5817befe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b320cc171e729a6fdfd4062cce1a75"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_u_s_b_h__device__info.html">USBH_device_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a45b320cc171e729a6fdfd4062cce1a75">USBH_device_info</a></td></tr>
<tr class="separator:a45b320cc171e729a6fdfd4062cce1a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce393490e2366d2804f36067d81bbf2"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_u_s_b_h__interface__info.html">USBH_interface_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#adce393490e2366d2804f36067d81bbf2">USBH_interface_info</a></td></tr>
<tr class="separator:adce393490e2366d2804f36067d81bbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b07fb3fa7af20825706dd6d0ba6732"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_u_s_b_h__endpoint__info.html">USBH_endpoint_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a46b07fb3fa7af20825706dd6d0ba6732">USBH_endpoint_info</a></td></tr>
<tr class="memdesc:a46b07fb3fa7af20825706dd6d0ba6732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing current information about an endpoint.  <a href="ft900__usbh_8h.html#a46b07fb3fa7af20825706dd6d0ba6732">More...</a><br /></td></tr>
<tr class="separator:a46b07fb3fa7af20825706dd6d0ba6732"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">USB Library Initialisation</div></td></tr>
<tr class="memitem:a335f88aebcf2306a5e0b35bcaff1f3e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a335f88aebcf2306a5e0b35bcaff1f3e8">USBH_initialise</a> (<a class="el" href="struct_u_s_b_h__ctx.html">USBH_ctx</a> *ctx)</td></tr>
<tr class="memdesc:a335f88aebcf2306a5e0b35bcaff1f3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise USB hardware.  <a href="ft900__usbh_8h.html#a335f88aebcf2306a5e0b35bcaff1f3e8">More...</a><br /></td></tr>
<tr class="separator:a335f88aebcf2306a5e0b35bcaff1f3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318788f579663b726d936c579fc006ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a318788f579663b726d936c579fc006ee">USBH_finalise</a> (void)</td></tr>
<tr class="memdesc:a318788f579663b726d936c579fc006ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalise USB hardware.  <a href="ft900__usbh_8h.html#a318788f579663b726d936c579fc006ee">More...</a><br /></td></tr>
<tr class="separator:a318788f579663b726d936c579fc006ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">HUB class requests</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Determine and control root and downstream hubs. </p>
</div></td></tr>
<tr class="memitem:a39cad44d8b690352119249d2737fb3ce"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a39cad44d8b690352119249d2737fb3ce">USBH_get_hub_port_count</a> (<a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> hub, uint8_t *count)</td></tr>
<tr class="memdesc:a39cad44d8b690352119249d2737fb3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of ports on specified hub.  <a href="ft900__usbh_8h.html#a39cad44d8b690352119249d2737fb3ce">More...</a><br /></td></tr>
<tr class="separator:a39cad44d8b690352119249d2737fb3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2650350fb1ae4aa96dde82e7f6be434"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#af2650350fb1ae4aa96dde82e7f6be434">USBH_get_hub_status</a> (<a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> hub, <a class="el" href="struct_u_s_b__hub__status.html">USB_hub_status</a> *status)</td></tr>
<tr class="memdesc:af2650350fb1ae4aa96dde82e7f6be434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return status specified hub.  <a href="ft900__usbh_8h.html#af2650350fb1ae4aa96dde82e7f6be434">More...</a><br /></td></tr>
<tr class="separator:af2650350fb1ae4aa96dde82e7f6be434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887ec4da76e0d432bed29bdc29559b63"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a887ec4da76e0d432bed29bdc29559b63">USBH_get_hub_port_status</a> (<a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> hub, const uint8_t port, <a class="el" href="struct_u_s_b__hub__port__status.html">USB_hub_port_status</a> *status)</td></tr>
<tr class="memdesc:a887ec4da76e0d432bed29bdc29559b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the specified port on the hub.  <a href="ft900__usbh_8h.html#a887ec4da76e0d432bed29bdc29559b63">More...</a><br /></td></tr>
<tr class="separator:a887ec4da76e0d432bed29bdc29559b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27010b63356352c65167054ce0f93d41"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a27010b63356352c65167054ce0f93d41">USBH_hub_set_feature</a> (<a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> hub, const uint16_t feature)</td></tr>
<tr class="memdesc:a27010b63356352c65167054ce0f93d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/Clear Features on hub.  <a href="ft900__usbh_8h.html#a27010b63356352c65167054ce0f93d41">More...</a><br /></td></tr>
<tr class="separator:a27010b63356352c65167054ce0f93d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7aaa5bf9391e8b8cb5fa5f006a627f"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a4b7aaa5bf9391e8b8cb5fa5f006a627f">USBH_hub_clear_feature</a> (<a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> hub, const uint16_t feature)</td></tr>
<tr class="separator:a4b7aaa5bf9391e8b8cb5fa5f006a627f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55bcb2caba467a92b6f518c2eed9774"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#ad55bcb2caba467a92b6f518c2eed9774">USBH_hub_set_port_feature</a> (<a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> hub, const uint8_t port, const uint16_t feature)</td></tr>
<tr class="memdesc:ad55bcb2caba467a92b6f518c2eed9774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/Clear Port Features on hub.  <a href="ft900__usbh_8h.html#ad55bcb2caba467a92b6f518c2eed9774">More...</a><br /></td></tr>
<tr class="separator:ad55bcb2caba467a92b6f518c2eed9774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231d7dbfe88bbd75512abc6c33e5cbc5"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a231d7dbfe88bbd75512abc6c33e5cbc5">USBH_hub_clear_port_feature</a> (<a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> hub, const uint8_t port, const uint16_t feature)</td></tr>
<tr class="separator:a231d7dbfe88bbd75512abc6c33e5cbc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Host Controller Control and Status Commands</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Connection and Enumeration related functions. </p>
</div></td></tr>
<tr class="memitem:a5f59ea06a5165773dc489b60731eb853"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a5f59ea06a5165773dc489b60731eb853">USBH_get_connect_state</a> (<a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> hub, const uint8_t port, <a class="el" href="ft900__usbh_8h.html#a2b13ed05d776f7ae491783d648860257">USBH_STATE</a> *state)</td></tr>
<tr class="memdesc:a5f59ea06a5165773dc489b60731eb853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a hub port has a downstream connection.  <a href="ft900__usbh_8h.html#a5f59ea06a5165773dc489b60731eb853">More...</a><br /></td></tr>
<tr class="separator:a5f59ea06a5165773dc489b60731eb853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3006f90211cfb5abf96c6f038e1585ba"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a3006f90211cfb5abf96c6f038e1585ba">USBH_get_controller_state</a> (<a class="el" href="ft900__usbh_8h.html#abeaaa88eea23ee200def87d082d61861">USBH_CONTROLLER_STATE</a> *state)</td></tr>
<tr class="memdesc:a3006f90211cfb5abf96c6f038e1585ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get host controller state.  <a href="ft900__usbh_8h.html#a3006f90211cfb5abf96c6f038e1585ba">More...</a><br /></td></tr>
<tr class="separator:a3006f90211cfb5abf96c6f038e1585ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a4f4de05d2c7a5c7df2a8beb5884bd"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#ab1a4f4de05d2c7a5c7df2a8beb5884bd">USBH_get_frame_number</a> (void)</td></tr>
<tr class="memdesc:ab1a4f4de05d2c7a5c7df2a8beb5884bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get frame number.  <a href="ft900__usbh_8h.html#ab1a4f4de05d2c7a5c7df2a8beb5884bd">More...</a><br /></td></tr>
<tr class="separator:ab1a4f4de05d2c7a5c7df2a8beb5884bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd699bfa8ac0d61feb24ab126ee154b"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a0dd699bfa8ac0d61feb24ab126ee154b">USBH_enumerate</a> (<a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> hub, uint8_t port)</td></tr>
<tr class="memdesc:a0dd699bfa8ac0d61feb24ab126ee154b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a re-enumeration of a hub.  <a href="ft900__usbh_8h.html#a0dd699bfa8ac0d61feb24ab126ee154b">More...</a><br /></td></tr>
<tr class="separator:a0dd699bfa8ac0d61feb24ab126ee154b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Finding Devices</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Discovering Devices after Enumeration. </p>
</div></td></tr>
<tr class="memitem:a7c6582fadcbd10507fe902544c368b9b"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a7c6582fadcbd10507fe902544c368b9b">USBH_get_device_count</a> (<a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> device, uint8_t *count)</td></tr>
<tr class="memdesc:a7c6582fadcbd10507fe902544c368b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get device count.  <a href="ft900__usbh_8h.html#a7c6582fadcbd10507fe902544c368b9b">More...</a><br /></td></tr>
<tr class="separator:a7c6582fadcbd10507fe902544c368b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7aa179da39bba41751eb3a11a559d5a"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#ab7aa179da39bba41751eb3a11a559d5a">USBH_get_device_list</a> (<a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> device, <a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> *child)</td></tr>
<tr class="memdesc:ab7aa179da39bba41751eb3a11a559d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get device list.  <a href="ft900__usbh_8h.html#ab7aa179da39bba41751eb3a11a559d5a">More...</a><br /></td></tr>
<tr class="separator:ab7aa179da39bba41751eb3a11a559d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9652c8204fd634f2b05be4f19595380c"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a9652c8204fd634f2b05be4f19595380c">USBH_get_next_device</a> (<a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> device, <a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> *next)</td></tr>
<tr class="memdesc:a9652c8204fd634f2b05be4f19595380c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next device in list.  <a href="ft900__usbh_8h.html#a9652c8204fd634f2b05be4f19595380c">More...</a><br /></td></tr>
<tr class="separator:a9652c8204fd634f2b05be4f19595380c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Finding Interfaces</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Discovering Interfaces of a Device after Enumeration. </p>
</div></td></tr>
<tr class="memitem:addef15439db42dd3a58064d2340616fe"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#addef15439db42dd3a58064d2340616fe">USBH_get_interface_count</a> (<a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> device, uint8_t *count)</td></tr>
<tr class="memdesc:addef15439db42dd3a58064d2340616fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interface count.  <a href="ft900__usbh_8h.html#addef15439db42dd3a58064d2340616fe">More...</a><br /></td></tr>
<tr class="separator:addef15439db42dd3a58064d2340616fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8fcaeb5decfa781ce1a74d83e967d5"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a4a8fcaeb5decfa781ce1a74d83e967d5">USBH_get_interface_list</a> (<a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> device, <a class="el" href="ft900__usbh_8h.html#a8ccfed31ca31c08159ef593468abf47f">USBH_interface_handle</a> *interface)</td></tr>
<tr class="memdesc:a4a8fcaeb5decfa781ce1a74d83e967d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interface list.  <a href="ft900__usbh_8h.html#a4a8fcaeb5decfa781ce1a74d83e967d5">More...</a><br /></td></tr>
<tr class="separator:a4a8fcaeb5decfa781ce1a74d83e967d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad78da0658ed46c38f16b690defaae3e"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#aad78da0658ed46c38f16b690defaae3e">USBH_get_next_interface</a> (<a class="el" href="ft900__usbh_8h.html#a8ccfed31ca31c08159ef593468abf47f">USBH_interface_handle</a> interface, <a class="el" href="ft900__usbh_8h.html#a8ccfed31ca31c08159ef593468abf47f">USBH_interface_handle</a> *next)</td></tr>
<tr class="memdesc:aad78da0658ed46c38f16b690defaae3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next interface in list.  <a href="ft900__usbh_8h.html#aad78da0658ed46c38f16b690defaae3e">More...</a><br /></td></tr>
<tr class="separator:aad78da0658ed46c38f16b690defaae3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Finding Endpoints</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Discovering Endpoints of a Device or Interface after Enumeration. </p>
</div></td></tr>
<tr class="memitem:aa2638ac4326a5fd4ec872f348c5aab83"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#aa2638ac4326a5fd4ec872f348c5aab83">USBH_get_control_endpoint</a> (<a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> device, <a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a> *endpoint)</td></tr>
<tr class="memdesc:aa2638ac4326a5fd4ec872f348c5aab83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get control endpoint.  <a href="ft900__usbh_8h.html#aa2638ac4326a5fd4ec872f348c5aab83">More...</a><br /></td></tr>
<tr class="separator:aa2638ac4326a5fd4ec872f348c5aab83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41979a81f2ee83c867c3b54ee803a051"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a41979a81f2ee83c867c3b54ee803a051">USBH_get_endpoint_count</a> (<a class="el" href="ft900__usbh_8h.html#a8ccfed31ca31c08159ef593468abf47f">USBH_interface_handle</a> interface, uint8_t *count)</td></tr>
<tr class="memdesc:a41979a81f2ee83c867c3b54ee803a051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get endpoint count.  <a href="ft900__usbh_8h.html#a41979a81f2ee83c867c3b54ee803a051">More...</a><br /></td></tr>
<tr class="separator:a41979a81f2ee83c867c3b54ee803a051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8623d05566de22a8527e7c791fce0391"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a8623d05566de22a8527e7c791fce0391">USBH_get_endpoint_list</a> (<a class="el" href="ft900__usbh_8h.html#a8ccfed31ca31c08159ef593468abf47f">USBH_interface_handle</a> interface, <a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a> *endpoint)</td></tr>
<tr class="memdesc:a8623d05566de22a8527e7c791fce0391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get endpoint list.  <a href="ft900__usbh_8h.html#a8623d05566de22a8527e7c791fce0391">More...</a><br /></td></tr>
<tr class="separator:a8623d05566de22a8527e7c791fce0391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4d2529908be70e649fe00921d8ed01"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a6b4d2529908be70e649fe00921d8ed01">USBH_get_next_endpoint</a> (<a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a> endpoint, <a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a> *next)</td></tr>
<tr class="memdesc:a6b4d2529908be70e649fe00921d8ed01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next endpoint in list.  <a href="ft900__usbh_8h.html#a6b4d2529908be70e649fe00921d8ed01">More...</a><br /></td></tr>
<tr class="separator:a6b4d2529908be70e649fe00921d8ed01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Querying Device, Interface and Endpoint information.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Discovering information of devices, interfaces and endpoints. </p>
</div></td></tr>
<tr class="memitem:ad833a09639eee45f96fa1dfd055feba0"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#ad833a09639eee45f96fa1dfd055feba0">USBH_device_get_vid_pid</a> (<a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> device, uint16_t *vid, uint16_t *pid)</td></tr>
<tr class="memdesc:ad833a09639eee45f96fa1dfd055feba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get device VID and PID.  <a href="ft900__usbh_8h.html#ad833a09639eee45f96fa1dfd055feba0">More...</a><br /></td></tr>
<tr class="separator:ad833a09639eee45f96fa1dfd055feba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281404d70e762a0b6a4263c846a8199d"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a281404d70e762a0b6a4263c846a8199d">USBH_interface_get_class_info</a> (<a class="el" href="ft900__usbh_8h.html#a8ccfed31ca31c08159ef593468abf47f">USBH_interface_handle</a> interface, uint8_t *devClass, uint8_t *devSubclass, uint8_t *devProtocol)</td></tr>
<tr class="memdesc:a281404d70e762a0b6a4263c846a8199d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interface class, subclass and protocol.  <a href="ft900__usbh_8h.html#a281404d70e762a0b6a4263c846a8199d">More...</a><br /></td></tr>
<tr class="separator:a281404d70e762a0b6a4263c846a8199d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe3f7001e70bd70a8939083c062be26"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#abbe3f7001e70bd70a8939083c062be26">USBH_device_get_info</a> (<a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> device, <a class="el" href="struct_u_s_b_h__device__info.html">USBH_device_info</a> *info)</td></tr>
<tr class="memdesc:abbe3f7001e70bd70a8939083c062be26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get device information.  <a href="ft900__usbh_8h.html#abbe3f7001e70bd70a8939083c062be26">More...</a><br /></td></tr>
<tr class="separator:abbe3f7001e70bd70a8939083c062be26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cef30f947c1e03f0cd2c2449565a842"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a9cef30f947c1e03f0cd2c2449565a842">USBH_interface_get_info</a> (<a class="el" href="ft900__usbh_8h.html#a8ccfed31ca31c08159ef593468abf47f">USBH_interface_handle</a> interface, <a class="el" href="struct_u_s_b_h__interface__info.html">USBH_interface_info</a> *info)</td></tr>
<tr class="memdesc:a9cef30f947c1e03f0cd2c2449565a842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interface information.  <a href="ft900__usbh_8h.html#a9cef30f947c1e03f0cd2c2449565a842">More...</a><br /></td></tr>
<tr class="separator:a9cef30f947c1e03f0cd2c2449565a842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff71c9de9a9065692316abd244c23a05"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#aff71c9de9a9065692316abd244c23a05">USBH_endpoint_get_info</a> (<a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a> endpoint, <a class="el" href="struct_u_s_b_h__endpoint__info.html">USBH_endpoint_info</a> *info)</td></tr>
<tr class="memdesc:aff71c9de9a9065692316abd244c23a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get endpoint information.  <a href="ft900__usbh_8h.html#aff71c9de9a9065692316abd244c23a05">More...</a><br /></td></tr>
<tr class="separator:aff71c9de9a9065692316abd244c23a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Low level control of interfaces and endpoints.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Create requests to modify the behaviour of devices, interfaces and endpoints. </p>
</div></td></tr>
<tr class="memitem:a326a942f2d94e5ae999d8f8aec0160d6"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a326a942f2d94e5ae999d8f8aec0160d6">USBH_set_interface</a> (<a class="el" href="ft900__usbh_8h.html#a8ccfed31ca31c08159ef593468abf47f">USBH_interface_handle</a> interface, const uint8_t alt)</td></tr>
<tr class="memdesc:a326a942f2d94e5ae999d8f8aec0160d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the alternate configuration of an interface.  <a href="ft900__usbh_8h.html#a326a942f2d94e5ae999d8f8aec0160d6">More...</a><br /></td></tr>
<tr class="separator:a326a942f2d94e5ae999d8f8aec0160d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2673dcb658bb64ad4ddcd67fe3050aa9"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a2673dcb658bb64ad4ddcd67fe3050aa9">USBH_device_get_configuration</a> (<a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> device, uint8_t *conf)</td></tr>
<tr class="memdesc:a2673dcb658bb64ad4ddcd67fe3050aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current configuration value of a device.  <a href="ft900__usbh_8h.html#a2673dcb658bb64ad4ddcd67fe3050aa9">More...</a><br /></td></tr>
<tr class="separator:a2673dcb658bb64ad4ddcd67fe3050aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f368e8c4134055e9ed0791f6d2bf77b"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a9f368e8c4134055e9ed0791f6d2bf77b">USBH_device_set_configuration</a> (<a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> device, const uint8_t conf)</td></tr>
<tr class="memdesc:a9f368e8c4134055e9ed0791f6d2bf77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current configuration value of a device.  <a href="ft900__usbh_8h.html#a9f368e8c4134055e9ed0791f6d2bf77b">More...</a><br /></td></tr>
<tr class="separator:a9f368e8c4134055e9ed0791f6d2bf77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50697700e0355211dc5dbcd38489db2"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#ab50697700e0355211dc5dbcd38489db2">USBH_device_get_descriptor</a> (<a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> device, uint8_t type, uint8_t index, size_t len, uint8_t *buf)</td></tr>
<tr class="memdesc:ab50697700e0355211dc5dbcd38489db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a descriptor from a device.  <a href="ft900__usbh_8h.html#ab50697700e0355211dc5dbcd38489db2">More...</a><br /></td></tr>
<tr class="separator:ab50697700e0355211dc5dbcd38489db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdb7702d7ce9e696abd4320d6fcf689"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a6bdb7702d7ce9e696abd4320d6fcf689">USBH_endpoint_halt</a> (<a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a> endpoint, const uint8_t request)</td></tr>
<tr class="memdesc:a6bdb7702d7ce9e696abd4320d6fcf689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets or clears an endpoint halt feature request to an endpoint.  <a href="ft900__usbh_8h.html#a6bdb7702d7ce9e696abd4320d6fcf689">More...</a><br /></td></tr>
<tr class="separator:a6bdb7702d7ce9e696abd4320d6fcf689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fade060e6319e5951961ff23d29a5a1"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a3fade060e6319e5951961ff23d29a5a1">USBH_device_remote_wakeup</a> (<a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> device, const uint8_t request)</td></tr>
<tr class="memdesc:a3fade060e6319e5951961ff23d29a5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets or clears a remote wakeup feature request to a device.  <a href="ft900__usbh_8h.html#a3fade060e6319e5951961ff23d29a5a1">More...</a><br /></td></tr>
<tr class="separator:a3fade060e6319e5951961ff23d29a5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Low level control of host controller.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Modify the behaviour of the host's connection to devices, interfaces and endpoints. </p>
</div></td></tr>
<tr class="memitem:a63fc8845b3438b03b8de6118930b1dd4"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a63fc8845b3438b03b8de6118930b1dd4">USBH_interface_set_host_halt</a> (<a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a> endpoint)</td></tr>
<tr class="memdesc:a63fc8845b3438b03b8de6118930b1dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the host controller to stop an endpoint.  <a href="ft900__usbh_8h.html#a63fc8845b3438b03b8de6118930b1dd4">More...</a><br /></td></tr>
<tr class="separator:a63fc8845b3438b03b8de6118930b1dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a20a6b83115330083ef88f112feda09"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a8a20a6b83115330083ef88f112feda09">USBH_interface_clear_host_halt</a> (<a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a> endpoint)</td></tr>
<tr class="memdesc:a8a20a6b83115330083ef88f112feda09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a halted flag on an endpoint in the host controller.  <a href="ft900__usbh_8h.html#a8a20a6b83115330083ef88f112feda09">More...</a><br /></td></tr>
<tr class="separator:a8a20a6b83115330083ef88f112feda09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2e0dc4d01859a1c20287c78f7a9d1c"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a3d2e0dc4d01859a1c20287c78f7a9d1c">USBH_clear_endpoint_transfers</a> (<a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a> endpoint)</td></tr>
<tr class="memdesc:a3d2e0dc4d01859a1c20287c78f7a9d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the host controller to clear all transfers for an endpoint.  <a href="ft900__usbh_8h.html#a3d2e0dc4d01859a1c20287c78f7a9d1c">More...</a><br /></td></tr>
<tr class="separator:a3d2e0dc4d01859a1c20287c78f7a9d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">USB Transactions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Functions to transfer data to or from Endpoints. </p>
</div></td></tr>
<tr class="memitem:a1f5c581b246bb6d73098094e7a0b141f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a1f5c581b246bb6d73098094e7a0b141f">USBH_device_setup_transfer</a> (<a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> device, <a class="el" href="struct_u_s_b__device__request.html">USB_device_request</a> *req, uint8_t *buffer, int16_t timeout)</td></tr>
<tr class="memdesc:a1f5c581b246bb6d73098094e7a0b141f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer data to/from a USB control endpoint.  <a href="ft900__usbh_8h.html#a1f5c581b246bb6d73098094e7a0b141f">More...</a><br /></td></tr>
<tr class="separator:a1f5c581b246bb6d73098094e7a0b141f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac475546cc9658d4b1359d705fda42148"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#ac475546cc9658d4b1359d705fda42148">USBH_transfer</a> (<a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a> endpoint, uint8_t *buffer, const size_t length, uint16_t timeout)</td></tr>
<tr class="memdesc:ac475546cc9658d4b1359d705fda42148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer data to/from a USB endpoint.  <a href="ft900__usbh_8h.html#ac475546cc9658d4b1359d705fda42148">More...</a><br /></td></tr>
<tr class="separator:ac475546cc9658d4b1359d705fda42148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d777431dd747c30318bdb6b5d3e4560"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a8d777431dd747c30318bdb6b5d3e4560">USBH_queue_transfer</a> (<a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a> endpoint, uint8_t *buffer, const size_t length)</td></tr>
<tr class="memdesc:a8d777431dd747c30318bdb6b5d3e4560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer data to/from a USB endpoint. (EXPERIMENTAL)  <a href="ft900__usbh_8h.html#a8d777431dd747c30318bdb6b5d3e4560">More...</a><br /></td></tr>
<tr class="separator:a8d777431dd747c30318bdb6b5d3e4560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a4c23039eb7b99f7b32091c0546c08"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#af5a4c23039eb7b99f7b32091c0546c08">USBH_transfer_async</a> (<a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a> endpoint, uint8_t *buffer, const size_t length, uint16_t timeout, uint32_t id, <a class="el" href="ft900__usbh_8h.html#afc85fd701b2d75f74ca4aa8b5301cb03">USBH_callback</a> cb)</td></tr>
<tr class="memdesc:af5a4c23039eb7b99f7b32091c0546c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously transfer data to/from a USB endpoint.  <a href="ft900__usbh_8h.html#af5a4c23039eb7b99f7b32091c0546c08">More...</a><br /></td></tr>
<tr class="separator:af5a4c23039eb7b99f7b32091c0546c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e45776e6ff90fc462478df28412f04"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#ae9e45776e6ff90fc462478df28412f04">USBH_process</a> (void)</td></tr>
<tr class="memdesc:ae9e45776e6ff90fc462478df28412f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB process.  <a href="ft900__usbh_8h.html#ae9e45776e6ff90fc462478df28412f04">More...</a><br /></td></tr>
<tr class="separator:ae9e45776e6ff90fc462478df28412f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab6b6f815009a2ab79d0a7d9d906a56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a6ab6b6f815009a2ab79d0a7d9d906a56">USBH_timer</a> (void)</td></tr>
<tr class="memdesc:a6ab6b6f815009a2ab79d0a7d9d906a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB timer.  <a href="ft900__usbh_8h.html#a6ab6b6f815009a2ab79d0a7d9d906a56">More...</a><br /></td></tr>
<tr class="separator:a6ab6b6f815009a2ab79d0a7d9d906a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Definitions for USB Hubs</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrp2573bfcfa7ea79f214ab871113c771c4"></a> Set of values for defining access to the hubs. </p>
</td></tr>
<tr class="memitem:a20363434a70e25231d9af5d3caf1da6b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a20363434a70e25231d9af5d3caf1da6b">USBH_ROOT_HUB_HANDLE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a20363434a70e25231d9af5d3caf1da6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle used to access Root hub.  <a href="ft900__usbh_8h.html#a20363434a70e25231d9af5d3caf1da6b">More...</a><br /></td></tr>
<tr class="separator:a20363434a70e25231d9af5d3caf1da6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6316b906c1aa0120888e12b3696d094e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a6316b906c1aa0120888e12b3696d094e">USBH_ROOT_HUB_PORT</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a6316b906c1aa0120888e12b3696d094e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Port used to access Root hub.  <a href="ft900__usbh_8h.html#a6316b906c1aa0120888e12b3696d094e">More...</a><br /></td></tr>
<tr class="separator:a6316b906c1aa0120888e12b3696d094e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204aa866e10132ac5484cb8abc8f15f5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a204aa866e10132ac5484cb8abc8f15f5">USBH_HUB_ALL_PORTS</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a204aa866e10132ac5484cb8abc8f15f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Port used to access all devices on a hub.  <a href="ft900__usbh_8h.html#a204aa866e10132ac5484cb8abc8f15f5">More...</a><br /></td></tr>
<tr class="separator:a204aa866e10132ac5484cb8abc8f15f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b13ed05d776f7ae491783d648860257"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a2b13ed05d776f7ae491783d648860257">USBH_STATE</a> { <a class="el" href="ft900__usbh_8h.html#a2b13ed05d776f7ae491783d648860257abf368d9edc7e3569ab2b9e889e110265">USBH_STATE_NOTCONNECTED</a>
, <a class="el" href="ft900__usbh_8h.html#a2b13ed05d776f7ae491783d648860257aa9978eb7efe9173403fcb453a8c5d879">USBH_STATE_CONNECTED</a>
, <a class="el" href="ft900__usbh_8h.html#a2b13ed05d776f7ae491783d648860257a8b276164bfa30026b08b3aef1ecb1c12">USBH_STATE_ENUMERATED</a>
, <a class="el" href="ft900__usbh_8h.html#a2b13ed05d776f7ae491783d648860257a01cb46750c53aacd0e0717c00969d887">USBH_STATE_ENUMERATED_PARTIAL</a>
 }</td></tr>
<tr class="memdesc:a2b13ed05d776f7ae491783d648860257"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Root Hub Connection States.  <a href="ft900__usbh_8h.html#a2b13ed05d776f7ae491783d648860257">More...</a><br /></td></tr>
<tr class="separator:a2b13ed05d776f7ae491783d648860257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeaaa88eea23ee200def87d082d61861"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#abeaaa88eea23ee200def87d082d61861">USBH_CONTROLLER_STATE</a> { <br />
&#160;&#160;<a class="el" href="ft900__usbh_8h.html#abeaaa88eea23ee200def87d082d61861ae473c85fac6f95371b839a5b6b7c7cc8">USBH_CONTROLLER_STATE_RESET</a>
, <a class="el" href="ft900__usbh_8h.html#abeaaa88eea23ee200def87d082d61861a8105120fd73921780485d63ccb0c9c68">USBH_CONTROLLER_STATE_OPERATIONAL</a>
, <a class="el" href="ft900__usbh_8h.html#abeaaa88eea23ee200def87d082d61861a7a9a05894574ce4bae17208d8619afb4">USBH_CONTROLLER_STATE_SUSPENDING</a>
, <a class="el" href="ft900__usbh_8h.html#abeaaa88eea23ee200def87d082d61861a5fe58e561b1df5318667f7955f843a30">USBH_CONTROLLER_STATE_SUSPEND</a>
, <br />
&#160;&#160;<a class="el" href="ft900__usbh_8h.html#abeaaa88eea23ee200def87d082d61861ad7e612638d5c2d8c6f7aff80b322d4a8">USBH_CONTROLLER_STATE_RESUME</a>
<br />
 }</td></tr>
<tr class="memdesc:abeaaa88eea23ee200def87d082d61861"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Host Controller State describing if the host is operational or suspending or resuming. Used to control transitions between these state.  <a href="ft900__usbh_8h.html#abeaaa88eea23ee200def87d082d61861">More...</a><br /></td></tr>
<tr class="separator:abeaaa88eea23ee200def87d082d61861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a0f9dc0b9e8825f9a0d6275658f342"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a65a0f9dc0b9e8825f9a0d6275658f342">USBH_ENDPOINT_TYPE</a> { <br />
&#160;&#160;<a class="el" href="ft900__usbh_8h.html#a65a0f9dc0b9e8825f9a0d6275658f342a522601d8da5b1c433d12a8b9e3461a11">USBH_EP_TYPE_DISABLED</a> = 0
, <a class="el" href="ft900__usbh_8h.html#a65a0f9dc0b9e8825f9a0d6275658f342a1bc42e48fbb6437f7ed713ba1a297b8c">USBH_EP_BULK</a> = 1
, <a class="el" href="ft900__usbh_8h.html#a65a0f9dc0b9e8825f9a0d6275658f342a84c123ee071d3145cf55598e40044096">USBH_EP_INT</a> = 2
, <a class="el" href="ft900__usbh_8h.html#a65a0f9dc0b9e8825f9a0d6275658f342ab48456c47c6440c8dcc4eb30372badea">USBH_EP_ISOC</a> = 3
, <br />
&#160;&#160;<a class="el" href="ft900__usbh_8h.html#a65a0f9dc0b9e8825f9a0d6275658f342ac363bcbd75646bc19890106ed6aff7af">USBH_EP_CTRL</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:a65a0f9dc0b9e8825f9a0d6275658f342"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Endpoint Types.  <a href="ft900__usbh_8h.html#a65a0f9dc0b9e8825f9a0d6275658f342">More...</a><br /></td></tr>
<tr class="separator:a65a0f9dc0b9e8825f9a0d6275658f342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33edf1417e78e5426bea39a93c8a0a44"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a33edf1417e78e5426bea39a93c8a0a44">USBH_ENDPOINT_DIR</a> { <a class="el" href="ft900__usbh_8h.html#a33edf1417e78e5426bea39a93c8a0a44a634becce61c17efe2dcd05f9307844f2">USBH_DIR_OUT</a>
, <a class="el" href="ft900__usbh_8h.html#a33edf1417e78e5426bea39a93c8a0a44a2b1acc1d405c832e154868a0f95fcdcf">USBH_DIR_IN</a>
, <a class="el" href="ft900__usbh_8h.html#a33edf1417e78e5426bea39a93c8a0a44aeb87624d01949d73e24533880f17a441">USBH_DIR_SETUP</a>
 }</td></tr>
<tr class="memdesc:a33edf1417e78e5426bea39a93c8a0a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Endpoint Direction.  <a href="ft900__usbh_8h.html#a33edf1417e78e5426bea39a93c8a0a44">More...</a><br /></td></tr>
<tr class="separator:a33edf1417e78e5426bea39a93c8a0a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f480e4877280b6be80075380695773"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#a15f480e4877280b6be80075380695773">USBH_ENDPOINT_SPEED</a> { <a class="el" href="ft900__usbh_8h.html#a15f480e4877280b6be80075380695773a990965f53e4306f343f1715865c136ca">USBH_SPEED_LOW</a>
, <a class="el" href="ft900__usbh_8h.html#a15f480e4877280b6be80075380695773a3772fa65e05fc38d3faa3c00fc984d0a">USBH_SPEED_FULL</a>
, <a class="el" href="ft900__usbh_8h.html#a15f480e4877280b6be80075380695773ada924e299720073258c73de46af66eac">USBH_SPEED_HIGH</a>
 }</td></tr>
<tr class="memdesc:a15f480e4877280b6be80075380695773"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Endpoint Speed.  <a href="ft900__usbh_8h.html#a15f480e4877280b6be80075380695773">More...</a><br /></td></tr>
<tr class="separator:a15f480e4877280b6be80075380695773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86eeebf74e2e484898e4ba5a5d66bf8"><td class="memItemLeft" align="right" valign="top">typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#ad86eeebf74e2e484898e4ba5a5d66bf8">USBH_ENDPOINT_NUMBER</a></td></tr>
<tr class="memdesc:ad86eeebf74e2e484898e4ba5a5d66bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Endpoint Numbers.  <a href="ft900__usbh_8h.html#ad86eeebf74e2e484898e4ba5a5d66bf8">More...</a><br /></td></tr>
<tr class="separator:ad86eeebf74e2e484898e4ba5a5d66bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bcde9451c5d8165064ffb3d5712f6c"><td class="memItemLeft" align="right" valign="top">typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#ac6bcde9451c5d8165064ffb3d5712f6c">USBH_ENDPOINT_SIZE</a></td></tr>
<tr class="memdesc:ac6bcde9451c5d8165064ffb3d5712f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Endpoint Sizes.  <a href="ft900__usbh_8h.html#ac6bcde9451c5d8165064ffb3d5712f6c">More...</a><br /></td></tr>
<tr class="separator:ac6bcde9451c5d8165064ffb3d5712f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc85fd701b2d75f74ca4aa8b5301cb03"><td class="memItemLeft" align="right" valign="top">typedef int8_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbh_8h.html#afc85fd701b2d75f74ca4aa8b5301cb03">USBH_callback</a>) (uint32_t id, int8_t status, size_t len, uint8_t *buffer)</td></tr>
<tr class="memdesc:afc85fd701b2d75f74ca4aa8b5301cb03"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB callback used when completing a transaction or receiving a notification from the USBH library. It is not permissible to make a call to <a class="el" href="ft900__usbh_8h.html#af5a4c23039eb7b99f7b32091c0546c08" title="Asynchronously transfer data to/from a USB endpoint.">USBH_transfer_async()</a> and specify a callback function. This will produce unspecified results.  <a href="ft900__usbh_8h.html#afc85fd701b2d75f74ca4aa8b5301cb03">More...</a><br /></td></tr>
<tr class="separator:afc85fd701b2d75f74ca4aa8b5301cb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >USB host stack API. </p>
<p >This contains USB Host API function definitions, constants and structures which are exposed in the API. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a27681211c81718cc119c210a2289ae6a" name="a27681211c81718cc119c210a2289ae6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27681211c81718cc119c210a2289ae6a">&#9670;&nbsp;</a></span>ALIGN32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ALIGN32&#160;&#160;&#160;__attribute__ ((aligned(4)))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2ae447e613731a4e7506d6bd54594ff" name="af2ae447e613731a4e7506d6bd54594ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ae447e613731a4e7506d6bd54594ff">&#9670;&nbsp;</a></span>USBH_ENUM_NO_CHANGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_ENUM_NO_CHANGE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>No change in enumeration. </p>

</div>
</div>
<a id="a898c0c1e53622a51be70120acf3faf55" name="a898c0c1e53622a51be70120acf3faf55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898c0c1e53622a51be70120acf3faf55">&#9670;&nbsp;</a></span>USBH_ENUM_PARTIAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_ENUM_PARTIAL&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial enumeration only. </p>

</div>
</div>
<a id="ae9f21082a5340c44e13f483efa4cf02f" name="ae9f21082a5340c44e13f483efa4cf02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f21082a5340c44e13f483efa4cf02f">&#9670;&nbsp;</a></span>USBH_ERR_BABBLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_ERR_BABBLE&#160;&#160;&#160;-18</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Endpoint data babble detected. </p>

</div>
</div>
<a id="aabac5dc6dca652af8534cceafd947163" name="aabac5dc6dca652af8534cceafd947163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabac5dc6dca652af8534cceafd947163">&#9670;&nbsp;</a></span>USBH_ERR_DATA_BUF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_ERR_DATA_BUF&#160;&#160;&#160;-17</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Endpoint data underun or overrun. </p>

</div>
</div>
<a id="ace38a3726a79569b481c917abdb5198e" name="ace38a3726a79569b481c917abdb5198e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace38a3726a79569b481c917abdb5198e">&#9670;&nbsp;</a></span>USBH_ERR_HALTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_ERR_HALTED&#160;&#160;&#160;-16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transaction completed with halted state. </p>

</div>
</div>
<a id="a3e764217788432baaf4a538eb90951e4" name="a3e764217788432baaf4a538eb90951e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e764217788432baaf4a538eb90951e4">&#9670;&nbsp;</a></span>USBH_ERR_HOST_HALTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_ERR_HOST_HALTED&#160;&#160;&#160;-3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Host controller halted. </p>

</div>
</div>
<a id="a45fc52aab3e65cdc4007b5a19cde00af" name="a45fc52aab3e65cdc4007b5a19cde00af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45fc52aab3e65cdc4007b5a19cde00af">&#9670;&nbsp;</a></span>USBH_ERR_MISSED_MICROFRAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_ERR_MISSED_MICROFRAME&#160;&#160;&#160;-20</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Endpoint data missed microframe. </p>

</div>
</div>
<a id="ab3aee7c4bc1609107e0ae8835a06f68d" name="ab3aee7c4bc1609107e0ae8835a06f68d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3aee7c4bc1609107e0ae8835a06f68d">&#9670;&nbsp;</a></span>USBH_ERR_NOT_FOUND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_ERR_NOT_FOUND&#160;&#160;&#160;-4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Endpoint, Device or Interface not found. </p>

</div>
</div>
<a id="a1e7bee00fb9919eb80bd7329e3fcc682" name="a1e7bee00fb9919eb80bd7329e3fcc682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7bee00fb9919eb80bd7329e3fcc682">&#9670;&nbsp;</a></span>USBH_ERR_PARAMETER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_ERR_PARAMETER&#160;&#160;&#160;-15</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request parameter error. </p>

</div>
</div>
<a id="ae221fe98bfd853a1a5f11b9aac1d0a65" name="ae221fe98bfd853a1a5f11b9aac1d0a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae221fe98bfd853a1a5f11b9aac1d0a65">&#9670;&nbsp;</a></span>USBH_ERR_PING_ERR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_ERR_PING_ERR&#160;&#160;&#160;-22</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Endpoint ping state. </p>

</div>
</div>
<a id="a3bf2a00937bfcba7b2e40253e4db78ac" name="a3bf2a00937bfcba7b2e40253e4db78ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf2a00937bfcba7b2e40253e4db78ac">&#9670;&nbsp;</a></span>USBH_ERR_REMOVED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_ERR_REMOVED&#160;&#160;&#160;-5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Endpoint, Device or Interface removed. </p>

</div>
</div>
<a id="ab5a40f7f491a9622c3ff39a0708e7b8c" name="ab5a40f7f491a9622c3ff39a0708e7b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a40f7f491a9622c3ff39a0708e7b8c">&#9670;&nbsp;</a></span>USBH_ERR_RESOURCES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_ERR_RESOURCES&#160;&#160;&#160;-1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lack of resources to perform USB Host function. </p>

</div>
</div>
<a id="aacd8c02de4d7d17816ace26e6dd4acb1" name="aacd8c02de4d7d17816ace26e6dd4acb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd8c02de4d7d17816ace26e6dd4acb1">&#9670;&nbsp;</a></span>USBH_ERR_SPLITX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_ERR_SPLITX&#160;&#160;&#160;-21</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Endpoint split transaction state. </p>

</div>
</div>
<a id="aa8ab254b50a73670f6a1ed19e9888f4d" name="aa8ab254b50a73670f6a1ed19e9888f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ab254b50a73670f6a1ed19e9888f4d">&#9670;&nbsp;</a></span>USBH_ERR_STALLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_ERR_STALLED&#160;&#160;&#160;-6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Endpoint stalled. </p>

</div>
</div>
<a id="a00d83e792a6f2bec208e925277e9057f" name="a00d83e792a6f2bec208e925277e9057f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d83e792a6f2bec208e925277e9057f">&#9670;&nbsp;</a></span>USBH_ERR_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_ERR_TIMEOUT&#160;&#160;&#160;-8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Endpoint transaction timeout. </p>

</div>
</div>
<a id="ad5548d70b0aaddb249786207f5fabb0d" name="ad5548d70b0aaddb249786207f5fabb0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5548d70b0aaddb249786207f5fabb0d">&#9670;&nbsp;</a></span>USBH_ERR_USBERR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_ERR_USBERR&#160;&#160;&#160;-2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Host controller completed and reported an error. </p>

</div>
</div>
<a id="a79db28d39407476c4ecebd5fb21f75f3" name="a79db28d39407476c4ecebd5fb21f75f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79db28d39407476c4ecebd5fb21f75f3">&#9670;&nbsp;</a></span>USBH_ERR_XACTERR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_ERR_XACTERR&#160;&#160;&#160;-19</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Endpoint data transaction error. </p>

</div>
</div>
<a id="a204aa866e10132ac5484cb8abc8f15f5" name="a204aa866e10132ac5484cb8abc8f15f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204aa866e10132ac5484cb8abc8f15f5">&#9670;&nbsp;</a></span>USBH_HUB_ALL_PORTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_HUB_ALL_PORTS&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Port used to access all devices on a hub. </p>

</div>
</div>
<a id="a5b3ea27703d8bb0c9d7d680d5e8cb7e8" name="a5b3ea27703d8bb0c9d7d680d5e8cb7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3ea27703d8bb0c9d7d680d5e8cb7e8">&#9670;&nbsp;</a></span>USBH_OK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_OK&#160;&#160;&#160;0x00</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Success for USB Host function. </p>

</div>
</div>
<a id="a20363434a70e25231d9af5d3caf1da6b" name="a20363434a70e25231d9af5d3caf1da6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20363434a70e25231d9af5d3caf1da6b">&#9670;&nbsp;</a></span>USBH_ROOT_HUB_HANDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_ROOT_HUB_HANDLE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle used to access Root hub. </p>

</div>
</div>
<a id="a6316b906c1aa0120888e12b3696d094e" name="a6316b906c1aa0120888e12b3696d094e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6316b906c1aa0120888e12b3696d094e">&#9670;&nbsp;</a></span>USBH_ROOT_HUB_PORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_ROOT_HUB_PORT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Port used to access Root hub. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="afc85fd701b2d75f74ca4aa8b5301cb03" name="afc85fd701b2d75f74ca4aa8b5301cb03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc85fd701b2d75f74ca4aa8b5301cb03">&#9670;&nbsp;</a></span>USBH_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USBH_callback</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB callback used when completing a transaction or receiving a notification from the USBH library. It is not permissible to make a call to <a class="el" href="ft900__usbh_8h.html#af5a4c23039eb7b99f7b32091c0546c08" title="Asynchronously transfer data to/from a USB endpoint.">USBH_transfer_async()</a> and specify a callback function. This will produce unspecified results. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Identifier for completed transaction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Status of operation that caused callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Size of data buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to data buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if the request was handled successfully. USBH_ERR_* depending on function. </dd></dl>

</div>
</div>
<a id="af411e8ac30392cf70a4b0df5817befe4" name="af411e8ac30392cf70a4b0df5817befe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af411e8ac30392cf70a4b0df5817befe4">&#9670;&nbsp;</a></span>USBH_ctx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_u_s_b_h__ctx.html">USBH_ctx</a> <a class="el" href="struct_u_s_b_h__ctx.html">USBH_ctx</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aebfe5028b9b46387e02a1572b83fddec" name="aebfe5028b9b46387e02a1572b83fddec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebfe5028b9b46387e02a1572b83fddec">&#9670;&nbsp;</a></span>USBH_device_handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure that is used to pass a handle to a device to the application. It is made up of a pointer to the device structure and a fairly unique value to detect enumeration changes and hence stale handles. </p>

</div>
</div>
<a id="a45b320cc171e729a6fdfd4062cce1a75" name="a45b320cc171e729a6fdfd4062cce1a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b320cc171e729a6fdfd4062cce1a75">&#9670;&nbsp;</a></span>USBH_device_info</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_u_s_b_h__device__info.html">USBH_device_info</a> <a class="el" href="struct_u_s_b_h__device__info.html">USBH_device_info</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fc30246a89dcc150be319f2178df101" name="a6fc30246a89dcc150be319f2178df101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc30246a89dcc150be319f2178df101">&#9670;&nbsp;</a></span>USBH_endpoint_handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure that is used to pass a handle to an endpoint to the application. It is made up of a pointer to the endpoint structure and a fairly unique value to detect enumeration changes and hence stale handles. </p>

</div>
</div>
<a id="a46b07fb3fa7af20825706dd6d0ba6732" name="a46b07fb3fa7af20825706dd6d0ba6732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b07fb3fa7af20825706dd6d0ba6732">&#9670;&nbsp;</a></span>USBH_endpoint_info</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_u_s_b_h__endpoint__info.html">USBH_endpoint_info</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Struct containing current information about an endpoint. </p>

</div>
</div>
<a id="ad86eeebf74e2e484898e4ba5a5d66bf8" name="ad86eeebf74e2e484898e4ba5a5d66bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86eeebf74e2e484898e4ba5a5d66bf8">&#9670;&nbsp;</a></span>USBH_ENDPOINT_NUMBER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ft900__usbh_8h.html#ad86eeebf74e2e484898e4ba5a5d66bf8">USBH_ENDPOINT_NUMBER</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB Endpoint Numbers. </p>

</div>
</div>
<a id="ac6bcde9451c5d8165064ffb3d5712f6c" name="ac6bcde9451c5d8165064ffb3d5712f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bcde9451c5d8165064ffb3d5712f6c">&#9670;&nbsp;</a></span>USBH_ENDPOINT_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ft900__usbh_8h.html#ac6bcde9451c5d8165064ffb3d5712f6c">USBH_ENDPOINT_SIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB Endpoint Sizes. </p>

</div>
</div>
<a id="a8ccfed31ca31c08159ef593468abf47f" name="a8ccfed31ca31c08159ef593468abf47f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ccfed31ca31c08159ef593468abf47f">&#9670;&nbsp;</a></span>USBH_interface_handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ft900__usbh_8h.html#a8ccfed31ca31c08159ef593468abf47f">USBH_interface_handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure that is used to pass a handle to an interface to the application. It is made up of a pointer to the interface structure and a fairly unique value to detect enumeration changes and hence stale handles. </p>

</div>
</div>
<a id="adce393490e2366d2804f36067d81bbf2" name="adce393490e2366d2804f36067d81bbf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce393490e2366d2804f36067d81bbf2">&#9670;&nbsp;</a></span>USBH_interface_info</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_u_s_b_h__interface__info.html">USBH_interface_info</a> <a class="el" href="struct_u_s_b_h__interface__info.html">USBH_interface_info</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="abeaaa88eea23ee200def87d082d61861" name="abeaaa88eea23ee200def87d082d61861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeaaa88eea23ee200def87d082d61861">&#9670;&nbsp;</a></span>USBH_CONTROLLER_STATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ft900__usbh_8h.html#abeaaa88eea23ee200def87d082d61861">USBH_CONTROLLER_STATE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB Host Controller State describing if the host is operational or suspending or resuming. Used to control transitions between these state. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abeaaa88eea23ee200def87d082d61861ae473c85fac6f95371b839a5b6b7c7cc8" name="abeaaa88eea23ee200def87d082d61861ae473c85fac6f95371b839a5b6b7c7cc8"></a>USBH_CONTROLLER_STATE_RESET&#160;</td><td class="fielddoc"><p >Controller reset and uninitialised. </p>
</td></tr>
<tr><td class="fieldname"><a id="abeaaa88eea23ee200def87d082d61861a8105120fd73921780485d63ccb0c9c68" name="abeaaa88eea23ee200def87d082d61861a8105120fd73921780485d63ccb0c9c68"></a>USBH_CONTROLLER_STATE_OPERATIONAL&#160;</td><td class="fielddoc"><p >Controller initialised and operational. </p>
</td></tr>
<tr><td class="fieldname"><a id="abeaaa88eea23ee200def87d082d61861a7a9a05894574ce4bae17208d8619afb4" name="abeaaa88eea23ee200def87d082d61861a7a9a05894574ce4bae17208d8619afb4"></a>USBH_CONTROLLER_STATE_SUSPENDING&#160;</td><td class="fielddoc"><p >Controller performing a suspend. Transitioning from operational to suspend. </p>
</td></tr>
<tr><td class="fieldname"><a id="abeaaa88eea23ee200def87d082d61861a5fe58e561b1df5318667f7955f843a30" name="abeaaa88eea23ee200def87d082d61861a5fe58e561b1df5318667f7955f843a30"></a>USBH_CONTROLLER_STATE_SUSPEND&#160;</td><td class="fielddoc"><p >Controller in suspend state. No SOFs generated. </p>
</td></tr>
<tr><td class="fieldname"><a id="abeaaa88eea23ee200def87d082d61861ad7e612638d5c2d8c6f7aff80b322d4a8" name="abeaaa88eea23ee200def87d082d61861ad7e612638d5c2d8c6f7aff80b322d4a8"></a>USBH_CONTROLLER_STATE_RESUME&#160;</td><td class="fielddoc"><p >Controller performing a resume. Transitioning from suspend to operational. </p>
</td></tr>
</table>

</div>
</div>
<a id="a33edf1417e78e5426bea39a93c8a0a44" name="a33edf1417e78e5426bea39a93c8a0a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33edf1417e78e5426bea39a93c8a0a44">&#9670;&nbsp;</a></span>USBH_ENDPOINT_DIR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ft900__usbh_8h.html#a33edf1417e78e5426bea39a93c8a0a44">USBH_ENDPOINT_DIR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB Endpoint Direction. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a33edf1417e78e5426bea39a93c8a0a44a634becce61c17efe2dcd05f9307844f2" name="a33edf1417e78e5426bea39a93c8a0a44a634becce61c17efe2dcd05f9307844f2"></a>USBH_DIR_OUT&#160;</td><td class="fielddoc"><p >Direction host to device. </p>
</td></tr>
<tr><td class="fieldname"><a id="a33edf1417e78e5426bea39a93c8a0a44a2b1acc1d405c832e154868a0f95fcdcf" name="a33edf1417e78e5426bea39a93c8a0a44a2b1acc1d405c832e154868a0f95fcdcf"></a>USBH_DIR_IN&#160;</td><td class="fielddoc"><p >Direction device to host. </p>
</td></tr>
<tr><td class="fieldname"><a id="a33edf1417e78e5426bea39a93c8a0a44aeb87624d01949d73e24533880f17a441" name="a33edf1417e78e5426bea39a93c8a0a44aeb87624d01949d73e24533880f17a441"></a>USBH_DIR_SETUP&#160;</td><td class="fielddoc"><p >Force a SETUP PID to a control endpoint. </p>
</td></tr>
</table>

</div>
</div>
<a id="a15f480e4877280b6be80075380695773" name="a15f480e4877280b6be80075380695773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f480e4877280b6be80075380695773">&#9670;&nbsp;</a></span>USBH_ENDPOINT_SPEED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ft900__usbh_8h.html#a15f480e4877280b6be80075380695773">USBH_ENDPOINT_SPEED</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB Endpoint Speed. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a15f480e4877280b6be80075380695773a990965f53e4306f343f1715865c136ca" name="a15f480e4877280b6be80075380695773a990965f53e4306f343f1715865c136ca"></a>USBH_SPEED_LOW&#160;</td><td class="fielddoc"><p >Low speed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a15f480e4877280b6be80075380695773a3772fa65e05fc38d3faa3c00fc984d0a" name="a15f480e4877280b6be80075380695773a3772fa65e05fc38d3faa3c00fc984d0a"></a>USBH_SPEED_FULL&#160;</td><td class="fielddoc"><p >Full speed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a15f480e4877280b6be80075380695773ada924e299720073258c73de46af66eac" name="a15f480e4877280b6be80075380695773ada924e299720073258c73de46af66eac"></a>USBH_SPEED_HIGH&#160;</td><td class="fielddoc"><p >High speed. </p>
</td></tr>
</table>

</div>
</div>
<a id="a65a0f9dc0b9e8825f9a0d6275658f342" name="a65a0f9dc0b9e8825f9a0d6275658f342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a0f9dc0b9e8825f9a0d6275658f342">&#9670;&nbsp;</a></span>USBH_ENDPOINT_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ft900__usbh_8h.html#a65a0f9dc0b9e8825f9a0d6275658f342">USBH_ENDPOINT_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB Endpoint Types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a65a0f9dc0b9e8825f9a0d6275658f342a522601d8da5b1c433d12a8b9e3461a11" name="a65a0f9dc0b9e8825f9a0d6275658f342a522601d8da5b1c433d12a8b9e3461a11"></a>USBH_EP_TYPE_DISABLED&#160;</td><td class="fielddoc"><p >Disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="a65a0f9dc0b9e8825f9a0d6275658f342a1bc42e48fbb6437f7ed713ba1a297b8c" name="a65a0f9dc0b9e8825f9a0d6275658f342a1bc42e48fbb6437f7ed713ba1a297b8c"></a>USBH_EP_BULK&#160;</td><td class="fielddoc"><p >Bulk Endpoint. </p>
</td></tr>
<tr><td class="fieldname"><a id="a65a0f9dc0b9e8825f9a0d6275658f342a84c123ee071d3145cf55598e40044096" name="a65a0f9dc0b9e8825f9a0d6275658f342a84c123ee071d3145cf55598e40044096"></a>USBH_EP_INT&#160;</td><td class="fielddoc"><p >Interrupt Endpoint. </p>
</td></tr>
<tr><td class="fieldname"><a id="a65a0f9dc0b9e8825f9a0d6275658f342ab48456c47c6440c8dcc4eb30372badea" name="a65a0f9dc0b9e8825f9a0d6275658f342ab48456c47c6440c8dcc4eb30372badea"></a>USBH_EP_ISOC&#160;</td><td class="fielddoc"><p >Isochronous Endpoint. </p>
</td></tr>
<tr><td class="fieldname"><a id="a65a0f9dc0b9e8825f9a0d6275658f342ac363bcbd75646bc19890106ed6aff7af" name="a65a0f9dc0b9e8825f9a0d6275658f342ac363bcbd75646bc19890106ed6aff7af"></a>USBH_EP_CTRL&#160;</td><td class="fielddoc"><p >Control Endpoint. </p>
</td></tr>
</table>

</div>
</div>
<a id="a2b13ed05d776f7ae491783d648860257" name="a2b13ed05d776f7ae491783d648860257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b13ed05d776f7ae491783d648860257">&#9670;&nbsp;</a></span>USBH_STATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ft900__usbh_8h.html#a2b13ed05d776f7ae491783d648860257">USBH_STATE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB Root Hub Connection States. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2b13ed05d776f7ae491783d648860257abf368d9edc7e3569ab2b9e889e110265" name="a2b13ed05d776f7ae491783d648860257abf368d9edc7e3569ab2b9e889e110265"></a>USBH_STATE_NOTCONNECTED&#160;</td><td class="fielddoc"><p >No device is attached to USB root hub. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2b13ed05d776f7ae491783d648860257aa9978eb7efe9173403fcb453a8c5d879" name="a2b13ed05d776f7ae491783d648860257aa9978eb7efe9173403fcb453a8c5d879"></a>USBH_STATE_CONNECTED&#160;</td><td class="fielddoc"><p >Device is attached to USB root hub. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2b13ed05d776f7ae491783d648860257a8b276164bfa30026b08b3aef1ecb1c12" name="a2b13ed05d776f7ae491783d648860257a8b276164bfa30026b08b3aef1ecb1c12"></a>USBH_STATE_ENUMERATED&#160;</td><td class="fielddoc"><p >Device is attached successfully enumerated. All downstream devices have also been successfully enumerated. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2b13ed05d776f7ae491783d648860257a01cb46750c53aacd0e0717c00969d887" name="a2b13ed05d776f7ae491783d648860257a01cb46750c53aacd0e0717c00969d887"></a>USBH_STATE_ENUMERATED_PARTIAL&#160;</td><td class="fielddoc"><p >Device is attached and has been partially enumerated. There may be more devices, interfaces or endpoints connected than configured. Some devices may be missing interfaces and/or endpoints. It is conceivable that some downstream devices may not be configured at all. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3d2e0dc4d01859a1c20287c78f7a9d1c" name="a3d2e0dc4d01859a1c20287c78f7a9d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d2e0dc4d01859a1c20287c78f7a9d1c">&#9670;&nbsp;</a></span>USBH_clear_endpoint_transfers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_clear_endpoint_transfers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a>&#160;</td>
          <td class="paramname"><em>endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the host controller to clear all transfers for an endpoint. </p>
<p >Clear the ECHI transaction queue for an endpoint. All transfers will be removed from the queue and invalidated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">endpoint</td><td>Handle to an endpoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_REMOVED endpoint removed. </dd></dl>

</div>
</div>
<a id="a2673dcb658bb64ad4ddcd67fe3050aa9" name="a2673dcb658bb64ad4ddcd67fe3050aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2673dcb658bb64ad4ddcd67fe3050aa9">&#9670;&nbsp;</a></span>USBH_device_get_configuration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_device_get_configuration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current configuration value of a device. </p>
<p >Sends a GET_CONFIGURATION request to a device. NOTE: Not strictly ever required. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Handle to a device. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">conf</td><td>Current configuration value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if device handle is invalid. USBH_ERR_RESOURCES if there are insufficient resources. USBH_ERR_* depending on USB bus errors. </dd></dl>

</div>
</div>
<a id="ab50697700e0355211dc5dbcd38489db2" name="ab50697700e0355211dc5dbcd38489db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50697700e0355211dc5dbcd38489db2">&#9670;&nbsp;</a></span>USBH_device_get_descriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_device_get_descriptor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a descriptor from a device. </p>
<p >Sends a GET_DESCRIPTOR request to a device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Handle to a device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Configuration descriptor type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index of descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Configuration descriptor len (or number of bytes to read). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Location to copy descriptor into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if device handle is invalid. USBH_ERR_RESOURCES if there are insufficient resources. USBH_ERR_* depending on USB bus errors. </dd></dl>

</div>
</div>
<a id="abbe3f7001e70bd70a8939083c062be26" name="abbe3f7001e70bd70a8939083c062be26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe3f7001e70bd70a8939083c062be26">&#9670;&nbsp;</a></span>USBH_device_get_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_device_get_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_h__device__info.html">USBH_device_info</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get device information. </p>
<p >Get information of a device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Handle to a device. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>Structure to receive device information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if device handle is invalid. </dd></dl>

</div>
</div>
<a id="ad833a09639eee45f96fa1dfd055feba0" name="ad833a09639eee45f96fa1dfd055feba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad833a09639eee45f96fa1dfd055feba0">&#9670;&nbsp;</a></span>USBH_device_get_vid_pid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_device_get_vid_pid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get device VID and PID. </p>
<p >Get the VID and PID of a device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Handle to a device. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vid</td><td>Vendor ID value from Device Descriptor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pid</td><td>Product ID value from Device Descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if device handle is invalid. </dd></dl>

</div>
</div>
<a id="a3fade060e6319e5951961ff23d29a5a1" name="a3fade060e6319e5951961ff23d29a5a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fade060e6319e5951961ff23d29a5a1">&#9670;&nbsp;</a></span>USBH_device_remote_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_device_remote_wakeup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets or clears a remote wakeup feature request to a device. </p>
<p >Sends a SET_FEATURE request to a device. This function is currently NOT IMPLEMENTED. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Handle to an device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Set or Clear Port feature. Described in Table 9-4 in Section 9.4 of the USB Specification. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if device handle is invalid. USBH_ERR_RESOURCES if there are insufficient resources. USBH_ERR_* depending on USB bus errors. </dd></dl>

</div>
</div>
<a id="a9f368e8c4134055e9ed0791f6d2bf77b" name="a9f368e8c4134055e9ed0791f6d2bf77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f368e8c4134055e9ed0791f6d2bf77b">&#9670;&nbsp;</a></span>USBH_device_set_configuration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_device_set_configuration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current configuration value of a device. </p>
<p >Sends a SET_CONFIGURATION request to a device. Forces reenumeration of the device with the new configuration. Handles referring to the previous configuration will expire and will need to be renewed with the new device configuration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Handle to a device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>New configuration value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if the device handle is invalid. USBH_ERR_RESOURCES if there are insufficient resources. USBH_ERR_* depending on USB bus errors. </dd></dl>

</div>
</div>
<a id="a1f5c581b246bb6d73098094e7a0b141f" name="a1f5c581b246bb6d73098094e7a0b141f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f5c581b246bb6d73098094e7a0b141f">&#9670;&nbsp;</a></span>USBH_device_setup_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t USBH_device_setup_transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_u_s_b__device__request.html">USB_device_request</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer data to/from a USB control endpoint. </p>
<p >USB <code>IN</code> or <code>OUT</code> request is implied from the <code>req</code> parameter. The length of the transfer is implied from the dwLength member of the <a class="el" href="struct_u_s_b__device__request.html" title="Structure representing a USB Device Request. USB Spec Table 9-2.">USB_device_request</a> structure. For <code>IN</code> transfers, length is the number of bytes to be sent. For <code>OUT</code> transfers, length is the maximum number of bytes to read. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device to address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>USB Device Request to send in SETUP token. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Appropriately sized buffer for the transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Number of milliseconds to wait for response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes transferred if successful. (i.e. &gt;= 0) USBH_ERR_NOT_FOUND if device handle is invalid. USBH_ERR_RESOURCES if there are insufficient resources. USBH_ERR_* depending on USB bus errors. </dd></dl>

</div>
</div>
<a id="aff71c9de9a9065692316abd244c23a05" name="aff71c9de9a9065692316abd244c23a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff71c9de9a9065692316abd244c23a05">&#9670;&nbsp;</a></span>USBH_endpoint_get_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_endpoint_get_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a>&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_h__endpoint__info.html">USBH_endpoint_info</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get endpoint information. </p>
<p >Get information of an endpoint. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">endpoint</td><td>Handle to an endpoint. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>Structure to receive endpoint information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if endpoint handle is invalid. </dd></dl>

</div>
</div>
<a id="a6bdb7702d7ce9e696abd4320d6fcf689" name="a6bdb7702d7ce9e696abd4320d6fcf689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bdb7702d7ce9e696abd4320d6fcf689">&#9670;&nbsp;</a></span>USBH_endpoint_halt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_endpoint_halt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a>&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets or clears an endpoint halt feature request to an endpoint. </p>
<p >Sends a SET_FEATURE request to a endpoint. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">endpoint</td><td>Handle to an endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Set or Clear Port feature. Described in Table 9-4 in Section 9.4 of the USB Specification. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if endpoint handle is invalid. USBH_ERR_RESOURCES if there are insufficient resources. USBH_ERR_* depending on USB bus errors. </dd></dl>

</div>
</div>
<a id="a0dd699bfa8ac0d61feb24ab126ee154b" name="a0dd699bfa8ac0d61feb24ab126ee154b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd699bfa8ac0d61feb24ab126ee154b">&#9670;&nbsp;</a></span>USBH_enumerate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_enumerate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a>&#160;</td>
          <td class="paramname"><em>hub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule a re-enumeration of a hub. </p>
<p >Select a hub to force re-enumeration. To enumerate the root hub the handle is set to USBH_ROOT_HUB_HANDLE or zero. To enumerate all ports on a hub set the port value to USBH_HUB_ALL_PORTS or zero. NOTE: The USB_process call will monitor the Root hub and downstream hubs to manage the connection/removal of devices after the initial enumeration is complete. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hub</td><td>Handle to hub device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Port on hub. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if hub handle is invalid. USBH_ERR_RESOURCES if there are insufficient resources. USBH_ERR_* depending on USB bus errors. </dd></dl>

</div>
</div>
<a id="a318788f579663b726d936c579fc006ee" name="a318788f579663b726d936c579fc006ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318788f579663b726d936c579fc006ee">&#9670;&nbsp;</a></span>USBH_finalise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBH_finalise </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalise USB hardware. </p>
<p >Releases any resources associated with the USB driver and disables the hardware. </p>

</div>
</div>
<a id="a5f59ea06a5165773dc489b60731eb853" name="a5f59ea06a5165773dc489b60731eb853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f59ea06a5165773dc489b60731eb853">&#9670;&nbsp;</a></span>USBH_get_connect_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_get_connect_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a>&#160;</td>
          <td class="paramname"><em>hub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#a2b13ed05d776f7ae491783d648860257">USBH_STATE</a> *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a hub port has a downstream connection. </p>
<p >Select a hub and a port to query. For the root hub the handle will be NULL and the port zero. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hub</td><td>Handle to hub device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Port number on hub. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">state</td><td>USBH_STATE enumeration for current state of hub port connection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if hub handle is invalid. USBH_ERR_* an error occurred sending the request to a USB hub. </dd></dl>

</div>
</div>
<a id="aa2638ac4326a5fd4ec872f348c5aab83" name="aa2638ac4326a5fd4ec872f348c5aab83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2638ac4326a5fd4ec872f348c5aab83">&#9670;&nbsp;</a></span>USBH_get_control_endpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_get_control_endpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a> *&#160;</td>
          <td class="paramname"><em>endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get control endpoint. </p>
<p >Get the control endpoint of a device. The function will return a handle to the control endpoint. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Handle to a device. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">endpoint</td><td>Handle to a control endpoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if device handle is invalid. </dd></dl>

</div>
</div>
<a id="a3006f90211cfb5abf96c6f038e1585ba" name="a3006f90211cfb5abf96c6f038e1585ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3006f90211cfb5abf96c6f038e1585ba">&#9670;&nbsp;</a></span>USBH_get_controller_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_get_controller_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#abeaaa88eea23ee200def87d082d61861">USBH_CONTROLLER_STATE</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get host controller state. </p>
<p >Get the state of the host controller. This may be used by an application to check if the controller is in suspend or operational state. There are intermediate states which can be found during transitions from operational to suspend and back. Recommended to use explicit state tests, i.e. "if state
            is suspended" rather than "if state is not operational". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">state</td><td>State enum for host. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. </dd></dl>

</div>
</div>
<a id="a7c6582fadcbd10507fe902544c368b9b" name="a7c6582fadcbd10507fe902544c368b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6582fadcbd10507fe902544c368b9b">&#9670;&nbsp;</a></span>USBH_get_device_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_get_device_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get device count. </p>
<p >Get the count of child device enumerated for a device. For devices on the root hub the handle is set to USBH_ROOT_HUB_HANDLE. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Count child devices on this device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">count</td><td>Number of child devices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if device handle is invalid. </dd></dl>

</div>
</div>
<a id="ab7aa179da39bba41751eb3a11a559d5a" name="ab7aa179da39bba41751eb3a11a559d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7aa179da39bba41751eb3a11a559d5a">&#9670;&nbsp;</a></span>USBH_get_device_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_get_device_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get device list. </p>
<p >Get the first child device of a device. The function will return a handle to a device if there is one or more child devices. For devices on the root hub the handle is set to USBH_ROOT_HUB_HANDLE. If there are no interface then a NULL is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Handle to a device. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">child</td><td>Handle to first child device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if device handle is invalid. </dd></dl>

</div>
</div>
<a id="a41979a81f2ee83c867c3b54ee803a051" name="a41979a81f2ee83c867c3b54ee803a051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41979a81f2ee83c867c3b54ee803a051">&#9670;&nbsp;</a></span>USBH_get_endpoint_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_get_endpoint_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#a8ccfed31ca31c08159ef593468abf47f">USBH_interface_handle</a>&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get endpoint count. </p>
<p >Get the count of endpoints enumerated for an interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interface</td><td>Count endpoints on this interface </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">count</td><td>Number of endpoints on interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if interface handle is invalid. </dd></dl>

</div>
</div>
<a id="a8623d05566de22a8527e7c791fce0391" name="a8623d05566de22a8527e7c791fce0391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8623d05566de22a8527e7c791fce0391">&#9670;&nbsp;</a></span>USBH_get_endpoint_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_get_endpoint_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#a8ccfed31ca31c08159ef593468abf47f">USBH_interface_handle</a>&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a> *&#160;</td>
          <td class="paramname"><em>endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get endpoint list. </p>
<p >Get the first endpoint of an interface. The function will return a handle to the endpoint if there is one or more endpoints. If there are no endpoint then a NULL is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interface</td><td>Handle to an interface. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">endpoint</td><td>Handle to first endpoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if interface handle is invalid. </dd></dl>

</div>
</div>
<a id="ab1a4f4de05d2c7a5c7df2a8beb5884bd" name="ab1a4f4de05d2c7a5c7df2a8beb5884bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a4f4de05d2c7a5c7df2a8beb5884bd">&#9670;&nbsp;</a></span>USBH_get_frame_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t USBH_get_frame_number </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get frame number. </p>
<p >Get the current frame number. This increments when the host is operational and will cease to increment when suspended. This number is sent in the SOF. </p><dl class="section return"><dt>Returns</dt><dd>Frame number (14 bit value). </dd></dl>

</div>
</div>
<a id="a39cad44d8b690352119249d2737fb3ce" name="a39cad44d8b690352119249d2737fb3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39cad44d8b690352119249d2737fb3ce">&#9670;&nbsp;</a></span>USBH_get_hub_port_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_get_hub_port_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a>&#160;</td>
          <td class="paramname"><em>hub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of ports on specified hub. </p>
<p >For the hub pointed to by the handle, return the number of ports that are available. For the root hub the handle will be NULL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hub</td><td>Handle to hub device. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">count</td><td>Number of ports on hub. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK on success.<br  />
 USBH_ERR_NOT_FOUND if hub handle is invalid. </dd></dl>

</div>
</div>
<a id="a887ec4da76e0d432bed29bdc29559b63" name="a887ec4da76e0d432bed29bdc29559b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887ec4da76e0d432bed29bdc29559b63">&#9670;&nbsp;</a></span>USBH_get_hub_port_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_get_hub_port_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a>&#160;</td>
          <td class="paramname"><em>hub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_u_s_b__hub__port__status.html">USB_hub_port_status</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the status of the specified port on the hub. </p>
<p >For the hub pointed to by the handle, return the status of the numbered port. For the root hub the handle will be NULL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hub</td><td>Handle to hub device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Port number on hub. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>Port status. As described in Table 11-21 of Section 11.24.2.7 in USB Specification. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK on success.<br  />
 USBH_ERR_NOT_FOUND if hub handle is invalid. USBH_ERR_* an error occurred querying a USB hub. </dd></dl>

</div>
</div>
<a id="af2650350fb1ae4aa96dde82e7f6be434" name="af2650350fb1ae4aa96dde82e7f6be434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2650350fb1ae4aa96dde82e7f6be434">&#9670;&nbsp;</a></span>USBH_get_hub_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_get_hub_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a>&#160;</td>
          <td class="paramname"><em>hub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_u_s_b__hub__status.html">USB_hub_status</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return status specified hub. </p>
<p >For the hub pointed to by the handle, return the status of the hub. For the root hub the handle will be NULL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hub</td><td>Handle to hub device. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>Hub status. As described in Table 11-19 and Table 11-20 of Section 11.24.2.6 in USB Specification. Status in low word and change in high word. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK on success.<br  />
 USBH_ERR_NOT_FOUND if hub handle is invalid. USBH_ERR_* an error occurred querying a USB hub. </dd></dl>

</div>
</div>
<a id="addef15439db42dd3a58064d2340616fe" name="addef15439db42dd3a58064d2340616fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addef15439db42dd3a58064d2340616fe">&#9670;&nbsp;</a></span>USBH_get_interface_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_get_interface_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get interface count. </p>
<p >Get the count of interfaces enumerated for a device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Count interface on this device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">count</td><td>Number of interfaces on device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if the device handle is invalid. </dd></dl>

</div>
</div>
<a id="a4a8fcaeb5decfa781ce1a74d83e967d5" name="a4a8fcaeb5decfa781ce1a74d83e967d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8fcaeb5decfa781ce1a74d83e967d5">&#9670;&nbsp;</a></span>USBH_get_interface_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_get_interface_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#a8ccfed31ca31c08159ef593468abf47f">USBH_interface_handle</a> *&#160;</td>
          <td class="paramname"><em>interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get interface list. </p>
<p >Get the first interface of a device. The function will return a handle to the interface if there is one or more interfaces. If there are no interface then a NULL is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Handle to a device. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">interface</td><td>Handle to the first interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if device handle is invalid. </dd></dl>

</div>
</div>
<a id="a9652c8204fd634f2b05be4f19595380c" name="a9652c8204fd634f2b05be4f19595380c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9652c8204fd634f2b05be4f19595380c">&#9670;&nbsp;</a></span>USBH_get_next_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_get_next_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a> *&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next device in list. </p>
<p >Get the next device in the list. The function will return a handle to the device if there are more devices. If there are no more devices then a NULL is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Handle to a device. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">next</td><td>Handle to the next device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if device handle is invalid. </dd></dl>

</div>
</div>
<a id="a6b4d2529908be70e649fe00921d8ed01" name="a6b4d2529908be70e649fe00921d8ed01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4d2529908be70e649fe00921d8ed01">&#9670;&nbsp;</a></span>USBH_get_next_endpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_get_next_endpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a>&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a> *&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next endpoint in list. </p>
<p >Get the next endpoint in the list. The function will return a handle to the endpoint if there are more endpoints. If there are no more endpoints then a NULL is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">endpoint</td><td>Handle to an endpoint. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">next</td><td>Handle to next endpoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if endpoint handle is invalid. </dd></dl>

</div>
</div>
<a id="aad78da0658ed46c38f16b690defaae3e" name="aad78da0658ed46c38f16b690defaae3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad78da0658ed46c38f16b690defaae3e">&#9670;&nbsp;</a></span>USBH_get_next_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_get_next_interface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#a8ccfed31ca31c08159ef593468abf47f">USBH_interface_handle</a>&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#a8ccfed31ca31c08159ef593468abf47f">USBH_interface_handle</a> *&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next interface in list. </p>
<p >Get the next interface in the list. The function will return a handle to the interface if there are more interfaces. If there are no more interfaces then a NULL is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interface</td><td>Handle to an interface. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">next</td><td>Handle to the next interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if interface handle is invalid. </dd></dl>

</div>
</div>
<a id="a4b7aaa5bf9391e8b8cb5fa5f006a627f" name="a4b7aaa5bf9391e8b8cb5fa5f006a627f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7aaa5bf9391e8b8cb5fa5f006a627f">&#9670;&nbsp;</a></span>USBH_hub_clear_feature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_hub_clear_feature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a>&#160;</td>
          <td class="paramname"><em>hub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>feature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a231d7dbfe88bbd75512abc6c33e5cbc5" name="a231d7dbfe88bbd75512abc6c33e5cbc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231d7dbfe88bbd75512abc6c33e5cbc5">&#9670;&nbsp;</a></span>USBH_hub_clear_port_feature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_hub_clear_port_feature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a>&#160;</td>
          <td class="paramname"><em>hub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>feature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27010b63356352c65167054ce0f93d41" name="a27010b63356352c65167054ce0f93d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27010b63356352c65167054ce0f93d41">&#9670;&nbsp;</a></span>USBH_hub_set_feature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_hub_set_feature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a>&#160;</td>
          <td class="paramname"><em>hub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>feature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set/Clear Features on hub. </p>
<p >For the hub pointed to by the handle, send a set or clear feature. For the root hub the handle will be NULL. Set or Clear feature operation described in Section 11.24.2.12 &amp; 11.24.2.1 of the USB Specification. NOTE: Split from USBH_hub_feature(). 8/12/2014 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hub</td><td>Handle to hub device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">feature</td><td>Port feature. As described in Table 11-17 of Section 11.24.2 in the USB Specification. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK on success.<br  />
 USBH_ERR_NOT_FOUND if hub handle is invalid. USBH_ERR_* an error occurred sending the request to a USB hub. </dd></dl>

</div>
</div>
<a id="ad55bcb2caba467a92b6f518c2eed9774" name="ad55bcb2caba467a92b6f518c2eed9774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55bcb2caba467a92b6f518c2eed9774">&#9670;&nbsp;</a></span>USBH_hub_set_port_feature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_hub_set_port_feature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#aebfe5028b9b46387e02a1572b83fddec">USBH_device_handle</a>&#160;</td>
          <td class="paramname"><em>hub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>feature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set/Clear Port Features on hub. </p>
<p >For the hub pointed to by the handle, send a set or clear port feature. For the root hub the handle will be NULL. Set or Clear Port feature operation described in Section 11.24.2.13 &amp; 11.24.2.2 of the USB Specification. NOTE: Split from USBH_hub_port_feature(). 8/12/2014 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hub</td><td>Handle to hub device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Port number on hub. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">feature</td><td>Port feature. As described in Table 11-17 of Section 11.24.2 in the USB Specification. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK on success.<br  />
 USBH_ERR_NOT_FOUND if hub handle is invalid. USBH_ERR_* an error occurred sending the request to a USB hub. </dd></dl>

</div>
</div>
<a id="a335f88aebcf2306a5e0b35bcaff1f3e8" name="a335f88aebcf2306a5e0b35bcaff1f3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335f88aebcf2306a5e0b35bcaff1f3e8">&#9670;&nbsp;</a></span>USBH_initialise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBH_initialise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_h__ctx.html">USBH_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise USB hardware. </p>
<p >Performs a software reset and initialises the USB host hardware. The <a class="el" href="struct_u_s_b_h__ctx.html" title="Struct containing configuration data for the USB EHCI controller, USBH memory space allocation,...">USBH_ctx</a> contains function pointers to the application for handling USB events. Currently only and enumeration change event is implemented. This function MUST be called prior to any further call to the USB functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>USB context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a20a6b83115330083ef88f112feda09" name="a8a20a6b83115330083ef88f112feda09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a20a6b83115330083ef88f112feda09">&#9670;&nbsp;</a></span>USBH_interface_clear_host_halt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_interface_clear_host_halt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a>&#160;</td>
          <td class="paramname"><em>endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a halted flag on an endpoint in the host controller. </p>
<p >Modify the ECHI endpoint data to remove the halt flag from a queue for an endpoint. This can only be used on BULK, INTERRUPT and CONTROL endpoint. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">endpoint</td><td>Handle to an endpoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_REMOVED endpoint removed. USBH_ERR_PARAMETER endpoint handle invalid. USBH_ERR_USBERR attempt to access an ISOCHRONOUS endpoint. USBH_ERR_NOT_FOUND if endpoint handle is invalid. </dd></dl>

</div>
</div>
<a id="a281404d70e762a0b6a4263c846a8199d" name="a281404d70e762a0b6a4263c846a8199d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281404d70e762a0b6a4263c846a8199d">&#9670;&nbsp;</a></span>USBH_interface_get_class_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_interface_get_class_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#a8ccfed31ca31c08159ef593468abf47f">USBH_interface_handle</a>&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>devClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>devSubclass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>devProtocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get interface class, subclass and protocol. </p>
<p >Get the class information of an interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interface</td><td>Handle to an interface. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">devClass</td><td>USB class value for the interface. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">devSubclass</td><td>USB subclass value for the interface. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">devProtocol</td><td>USB protocol value for the interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if interface handle is invalid. </dd></dl>

</div>
</div>
<a id="a9cef30f947c1e03f0cd2c2449565a842" name="a9cef30f947c1e03f0cd2c2449565a842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cef30f947c1e03f0cd2c2449565a842">&#9670;&nbsp;</a></span>USBH_interface_get_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_interface_get_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#a8ccfed31ca31c08159ef593468abf47f">USBH_interface_handle</a>&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_h__interface__info.html">USBH_interface_info</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get interface information. </p>
<p >Get information of an interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interface</td><td>Handle to an interface. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>Structure to receive interface information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if interface handle is invalid. </dd></dl>

</div>
</div>
<a id="a63fc8845b3438b03b8de6118930b1dd4" name="a63fc8845b3438b03b8de6118930b1dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fc8845b3438b03b8de6118930b1dd4">&#9670;&nbsp;</a></span>USBH_interface_set_host_halt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_interface_set_host_halt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a>&#160;</td>
          <td class="paramname"><em>endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the host controller to stop an endpoint. </p>
<p >Instruct the USB host controller to halt an endpoint. This can only be used on BULK, INTERRUPT and CONTROL endpoint. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">endpoint</td><td>Handle to an endpoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_REMOVED endpoint removed. USBH_ERR_PARAMETER endpoint handle invalid. USBH_ERR_USBERR attempt to access an ISOCHRONOUS endpoint. USBH_ERR_NOT_FOUND if endpoint handle is invalid. </dd></dl>

</div>
</div>
<a id="ae9e45776e6ff90fc462478df28412f04" name="ae9e45776e6ff90fc462478df28412f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e45776e6ff90fc462478df28412f04">&#9670;&nbsp;</a></span>USBH_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_process </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB process. </p>
<p >To be continuously called by the user application. Checks for asynchronous transfer completions and root hub events. When a root hub connection is detected then the enumeration routine is called automatically. </p><dl class="section return"><dt>Returns</dt><dd>Non-zero if USB transaction has been processed. </dd></dl>

</div>
</div>
<a id="a8d777431dd747c30318bdb6b5d3e4560" name="a8d777431dd747c30318bdb6b5d3e4560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d777431dd747c30318bdb6b5d3e4560">&#9670;&nbsp;</a></span>USBH_queue_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_queue_transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a>&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer data to/from a USB endpoint. (EXPERIMENTAL) </p>
<p >USB <code>IN</code> or <code>OUT</code> request is implied from the <code>ep</code> parameter. This is a non-blocking call to queue multiple transactions on an endpoint until a USBH_transfer is used to start the transfer queue. This function is currently NOT IMPLEMENTED. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">endpoint</td><td>Endpoint to address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Appropriately sized buffer for the transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>For <code>IN</code> transfers, the number of bytes to be sent. For <code>OUT</code> transfers, the maximum number of bytes to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if endpoint handle is invalid. USBH_ERR_RESOURCES if there are insufficient resources. USBH_ERR_* depending on USB bus errors. </dd></dl>

</div>
</div>
<a id="a326a942f2d94e5ae999d8f8aec0160d6" name="a326a942f2d94e5ae999d8f8aec0160d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326a942f2d94e5ae999d8f8aec0160d6">&#9670;&nbsp;</a></span>USBH_set_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBH_set_interface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#a8ccfed31ca31c08159ef593468abf47f">USBH_interface_handle</a>&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>alt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the alternate configuration of an interface. </p>
<p >Sends a SET_INTERFACE request to an interface. This function is currently NOT IMPLEMENTED. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interface</td><td>Handle to an interface. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alt</td><td>Alternate setting to send. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBH_OK if successful. USBH_ERR_NOT_FOUND if interface handle is invalid. USBH_ERR_RESOURCES if there are insufficient resources. USBH_ERR_* depending on USB bus errors. </dd></dl>

</div>
</div>
<a id="a6ab6b6f815009a2ab79d0a7d9d906a56" name="a6ab6b6f815009a2ab79d0a7d9d906a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab6b6f815009a2ab79d0a7d9d906a56">&#9670;&nbsp;</a></span>USBH_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBH_timer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB timer. </p>
<p >To be called every millisecond from an interrupt handler to provide timeout support for USB host transactions. This will check all pending transfers, decrement timeout values and expire any timed out transactions. </p>

</div>
</div>
<a id="ac475546cc9658d4b1359d705fda42148" name="ac475546cc9658d4b1359d705fda42148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac475546cc9658d4b1359d705fda42148">&#9670;&nbsp;</a></span>USBH_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t USBH_transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a>&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer data to/from a USB endpoint. </p>
<p >USB <code>IN</code> or <code>OUT</code> request is implied from the <code>ep</code> parameter. This is a blocking call to complete a transaction. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">endpoint</td><td>Endpoint to address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Appropriately sized buffer for the transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>For <code>IN</code> transfers, the number of bytes to be sent. For <code>OUT</code> transfers, the maximum number of bytes to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Number of milliseconds to wait for response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes transferred if successful. (i.e. &gt;= 0) USBH_ERR_NOT_FOUND if endpoint handle is invalid. USBH_ERR_RESOURCES if there are insufficient resources. USBH_ERR_* depending on USB bus errors. </dd></dl>

</div>
</div>
<a id="af5a4c23039eb7b99f7b32091c0546c08" name="af5a4c23039eb7b99f7b32091c0546c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a4c23039eb7b99f7b32091c0546c08">&#9670;&nbsp;</a></span>USBH_transfer_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t USBH_transfer_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#a6fc30246a89dcc150be319f2178df101">USBH_endpoint_handle</a>&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ft900__usbh_8h.html#afc85fd701b2d75f74ca4aa8b5301cb03">USBH_callback</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously transfer data to/from a USB endpoint. </p>
<p >USB <code>IN</code> or <code>OUT</code> request is implied from the <code>ep</code> parameter. This is a blocking call to complete a transaction. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">endpoint</td><td>Endpoint to address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Appropriately sized buffer for the transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>For <code>IN</code> transfers, the number of bytes to be sent. For <code>OUT</code> transfers, the maximum number of bytes to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Number of milliseconds to wait for response. Zero for infinite timeout. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Identifier for asynchronous transaction. Passed to the callback function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback function to notify application of completion of asynchronous transfer. Parameters for callback function are defined in the USBH_callback typedef. The status of the transaction and any pending data (from an IN) will be returned to the callback function. The function must return with minimum processing. When it returns the USB_xfer structure is discarded and invalidated. It is not permissible to make further calls to this function from with the callback function.This will produce unspecified results. SETUP and blocking calls are allowed but may have a performance penalty on application code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No callback returns the number of bytes transferred if successful. (i.e. &gt;= 0) With callback USBH_OK if successful. USBH_ERR_NOT_FOUND if endpoint handle is invalid. USBH_ERR_RESOURCES if there are insufficient resources. USBH_ERR_* depending on USB bus errors. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 7 2022 14:07:40 for libft900 by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
