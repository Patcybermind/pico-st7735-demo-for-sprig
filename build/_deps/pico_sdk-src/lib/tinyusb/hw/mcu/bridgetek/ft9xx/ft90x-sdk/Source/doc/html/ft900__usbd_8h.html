<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libft900: include/ft900_usbd.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="brtlogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">libft900<span id="projectnumber">&#160;2.6.0</span>
   </div>
   <div id="projectbrief">A hardware abstraction library for the FT9xx</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle"><div class="title">ft900_usbd.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>USB Device API.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d__ctx.html">USBD_ctx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing callback functions for the USB upper layer driver and callback functions for USB suspend/resume and USB reset. Sets USBD configuration information.  <a href="struct_u_s_b_d__ctx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Device initialisation.</div></td></tr>
<tr class="memitem:a7008036eb3ba34bbf12a8dba8f9d0fba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a7008036eb3ba34bbf12a8dba8f9d0fba">USBD_initialise</a> (<a class="el" href="struct_u_s_b_d__ctx.html">USBD_ctx</a> *ctx)</td></tr>
<tr class="memdesc:a7008036eb3ba34bbf12a8dba8f9d0fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise USB hardware.  <a href="ft900__usbd_8h.html#a7008036eb3ba34bbf12a8dba8f9d0fba">More...</a><br /></td></tr>
<tr class="separator:a7008036eb3ba34bbf12a8dba8f9d0fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d269eb6fcb0ef90d9cc2b3d7ec1dd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#aa0d269eb6fcb0ef90d9cc2b3d7ec1dd3">USBD_finalise</a> (void)</td></tr>
<tr class="memdesc:aa0d269eb6fcb0ef90d9cc2b3d7ec1dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalise USB hardware.  <a href="ft900__usbd_8h.html#aa0d269eb6fcb0ef90d9cc2b3d7ec1dd3">More...</a><br /></td></tr>
<tr class="separator:aa0d269eb6fcb0ef90d9cc2b3d7ec1dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6119c3e3bd9b1a486ade5561f8b4df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#acf6119c3e3bd9b1a486ade5561f8b4df">USBD_attach</a> (void)</td></tr>
<tr class="memdesc:acf6119c3e3bd9b1a486ade5561f8b4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach USB hardware.  <a href="ft900__usbd_8h.html#acf6119c3e3bd9b1a486ade5561f8b4df">More...</a><br /></td></tr>
<tr class="separator:acf6119c3e3bd9b1a486ade5561f8b4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577c02a3d1820b01494f9e8492a8ac3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a577c02a3d1820b01494f9e8492a8ac3b">USBD_detach</a> (void)</td></tr>
<tr class="memdesc:a577c02a3d1820b01494f9e8492a8ac3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach USB hardware.  <a href="ft900__usbd_8h.html#a577c02a3d1820b01494f9e8492a8ac3b">More...</a><br /></td></tr>
<tr class="separator:a577c02a3d1820b01494f9e8492a8ac3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Physical connection detection.</div></td></tr>
<tr class="memitem:a2a8749e74bcaae4bfb7d6c241d4313b6"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a2a8749e74bcaae4bfb7d6c241d4313b6">USBD_is_connected</a> (void)</td></tr>
<tr class="memdesc:a2a8749e74bcaae4bfb7d6c241d4313b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the device is connected to a host (or external power source).  <a href="ft900__usbd_8h.html#a2a8749e74bcaae4bfb7d6c241d4313b6">More...</a><br /></td></tr>
<tr class="separator:a2a8749e74bcaae4bfb7d6c241d4313b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71f8a4b3db728e169ed04383392b506"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#af71f8a4b3db728e169ed04383392b506">USBD_connect</a> (void)</td></tr>
<tr class="memdesc:af71f8a4b3db728e169ed04383392b506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to a USB host.  <a href="ft900__usbd_8h.html#af71f8a4b3db728e169ed04383392b506">More...</a><br /></td></tr>
<tr class="separator:af71f8a4b3db728e169ed04383392b506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Device USB Standard Request support.</div></td></tr>
<tr class="memitem:a60c02884a863d96c5da88895d6c7ddab"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a60c02884a863d96c5da88895d6c7ddab">USBD_req_set_address</a> (<a class="el" href="struct_u_s_b__device__request.html">USB_device_request</a> *req)</td></tr>
<tr class="memdesc:a60c02884a863d96c5da88895d6c7ddab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles SET_ADDRESS request.  <a href="ft900__usbd_8h.html#a60c02884a863d96c5da88895d6c7ddab">More...</a><br /></td></tr>
<tr class="separator:a60c02884a863d96c5da88895d6c7ddab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a12fee5f06e54d394f52a3281c89b9"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a87a12fee5f06e54d394f52a3281c89b9">USBD_req_set_configuration</a> (<a class="el" href="struct_u_s_b__device__request.html">USB_device_request</a> *req)</td></tr>
<tr class="memdesc:a87a12fee5f06e54d394f52a3281c89b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles SET_CONFIGURATION request.  <a href="ft900__usbd_8h.html#a87a12fee5f06e54d394f52a3281c89b9">More...</a><br /></td></tr>
<tr class="separator:a87a12fee5f06e54d394f52a3281c89b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16957bd5720ec123867e187a61dd7b59"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a16957bd5720ec123867e187a61dd7b59">USBD_req_get_configuration</a> (void)</td></tr>
<tr class="memdesc:a16957bd5720ec123867e187a61dd7b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles GET_CONFIGURATION request.  <a href="ft900__usbd_8h.html#a16957bd5720ec123867e187a61dd7b59">More...</a><br /></td></tr>
<tr class="separator:a16957bd5720ec123867e187a61dd7b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Device endpoint control support.</div></td></tr>
<tr class="memitem:ab3608e7e6c3334d9203f93151424aceb"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#ab3608e7e6c3334d9203f93151424aceb">USBD_stall_endpoint</a> (<a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">USBD_ENDPOINT_NUMBER</a> ep_number)</td></tr>
<tr class="memdesc:ab3608e7e6c3334d9203f93151424aceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stall endpoint.  <a href="ft900__usbd_8h.html#ab3608e7e6c3334d9203f93151424aceb">More...</a><br /></td></tr>
<tr class="separator:ab3608e7e6c3334d9203f93151424aceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b972e52e9a936df8760d9a7a5ae89ed"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a9b972e52e9a936df8760d9a7a5ae89ed">USBD_clear_endpoint</a> (<a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">USBD_ENDPOINT_NUMBER</a> ep_number)</td></tr>
<tr class="memdesc:a9b972e52e9a936df8760d9a7a5ae89ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears endpoint stall.  <a href="ft900__usbd_8h.html#a9b972e52e9a936df8760d9a7a5ae89ed">More...</a><br /></td></tr>
<tr class="separator:a9b972e52e9a936df8760d9a7a5ae89ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Device USB State machine support.</div></td></tr>
<tr class="memitem:ada576592480413ec6635cbf598980e49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ft900__usbd_8h.html#a21849edc8e9a97fefd204a4875c27c19">USBD_STATE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#ada576592480413ec6635cbf598980e49">USBD_get_state</a> (void)</td></tr>
<tr class="memdesc:ada576592480413ec6635cbf598980e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get USB state.  <a href="ft900__usbd_8h.html#ada576592480413ec6635cbf598980e49">More...</a><br /></td></tr>
<tr class="separator:ada576592480413ec6635cbf598980e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0075280857bc153c35a279913a60f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a6f0075280857bc153c35a279913a60f5">USBD_set_state</a> (<a class="el" href="ft900__usbd_8h.html#a21849edc8e9a97fefd204a4875c27c19">USBD_STATE</a> state)</td></tr>
<tr class="memdesc:a6f0075280857bc153c35a279913a60f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set USB state.  <a href="ft900__usbd_8h.html#a6f0075280857bc153c35a279913a60f5">More...</a><br /></td></tr>
<tr class="separator:a6f0075280857bc153c35a279913a60f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Device endpoint status support.</div></td></tr>
<tr class="memitem:a0c3e39b942284dede1a29d2a5037af56"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a0c3e39b942284dede1a29d2a5037af56">USBD_ep_buffer_full</a> (<a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">USBD_ENDPOINT_NUMBER</a> ep_number)</td></tr>
<tr class="memdesc:a0c3e39b942284dede1a29d2a5037af56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get USB endpoint buffer status.  <a href="ft900__usbd_8h.html#a0c3e39b942284dede1a29d2a5037af56">More...</a><br /></td></tr>
<tr class="separator:a0c3e39b942284dede1a29d2a5037af56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a0ef2de2d0e76f0f371e9f81e6ae13"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#ab8a0ef2de2d0e76f0f371e9f81e6ae13">USBD_get_ep_stalled</a> (<a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">USBD_ENDPOINT_NUMBER</a> ep_number)</td></tr>
<tr class="memdesc:ab8a0ef2de2d0e76f0f371e9f81e6ae13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get USB endpoint stall status.  <a href="ft900__usbd_8h.html#ab8a0ef2de2d0e76f0f371e9f81e6ae13">More...</a><br /></td></tr>
<tr class="separator:ab8a0ef2de2d0e76f0f371e9f81e6ae13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Device remote wakeup support.</div></td></tr>
<tr class="memitem:a2708e6c69d50792ffd53dfe4a3ee9ded"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a2708e6c69d50792ffd53dfe4a3ee9ded">USBD_get_remote_wakeup</a> (void)</td></tr>
<tr class="memdesc:a2708e6c69d50792ffd53dfe4a3ee9ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get USB remote wakeup feature status.  <a href="ft900__usbd_8h.html#a2708e6c69d50792ffd53dfe4a3ee9ded">More...</a><br /></td></tr>
<tr class="separator:a2708e6c69d50792ffd53dfe4a3ee9ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab044ab14b72587ceb4cc38d00e0bb404"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#ab044ab14b72587ceb4cc38d00e0bb404">USBD_set_remote_wakeup</a> (void)</td></tr>
<tr class="memdesc:ab044ab14b72587ceb4cc38d00e0bb404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set USB remote wakeup feature status.  <a href="ft900__usbd_8h.html#ab044ab14b72587ceb4cc38d00e0bb404">More...</a><br /></td></tr>
<tr class="separator:ab044ab14b72587ceb4cc38d00e0bb404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84490fa8bbba171200b9fbdfca1e9d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#ad84490fa8bbba171200b9fbdfca1e9d2">USBD_clear_remote_wakeup</a> (void)</td></tr>
<tr class="memdesc:ad84490fa8bbba171200b9fbdfca1e9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear USB remote wakeup feature status.  <a href="ft900__usbd_8h.html#ad84490fa8bbba171200b9fbdfca1e9d2">More...</a><br /></td></tr>
<tr class="separator:ad84490fa8bbba171200b9fbdfca1e9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26051cd0b73ac47f0902caa3e89d56b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#ad26051cd0b73ac47f0902caa3e89d56b">USBD_wakeup</a> (void)</td></tr>
<tr class="memdesc:ad26051cd0b73ac47f0902caa3e89d56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume signalling for remote wakeup.  <a href="ft900__usbd_8h.html#ad26051cd0b73ac47f0902caa3e89d56b">More...</a><br /></td></tr>
<tr class="separator:ad26051cd0b73ac47f0902caa3e89d56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe9106a038ff6e7244da1d402546dce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#abbe9106a038ff6e7244da1d402546dce">USBD_resume</a> (void)</td></tr>
<tr class="memdesc:abbe9106a038ff6e7244da1d402546dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume from Suspend.  <a href="ft900__usbd_8h.html#abbe9106a038ff6e7244da1d402546dce">More...</a><br /></td></tr>
<tr class="separator:abbe9106a038ff6e7244da1d402546dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Definitions for USB Device return values</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrp4d819fb0dcce1fba0c47264c520d4185"></a> Set of return values from USB Device API calls. </p>
</td></tr>
<tr class="memitem:a72853344bafffd1eff9dd94d81ca3a10"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a72853344bafffd1eff9dd94d81ca3a10">USBD_OK</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="memdesc:a72853344bafffd1eff9dd94d81ca3a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Success for USB Host function.  <a href="ft900__usbd_8h.html#a72853344bafffd1eff9dd94d81ca3a10">More...</a><br /></td></tr>
<tr class="separator:a72853344bafffd1eff9dd94d81ca3a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36fb087126cbf9fc6dfc501e964b51f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#ad36fb087126cbf9fc6dfc501e964b51f">USBD_ERR_INVALID_PARAMETER</a>&#160;&#160;&#160;-1</td></tr>
<tr class="memdesc:ad36fb087126cbf9fc6dfc501e964b51f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid parameter supplied to API function.  <a href="ft900__usbd_8h.html#ad36fb087126cbf9fc6dfc501e964b51f">More...</a><br /></td></tr>
<tr class="separator:ad36fb087126cbf9fc6dfc501e964b51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9638bd83ff30e7790536ff11138d431b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a9638bd83ff30e7790536ff11138d431b">USBD_ERR_NOT_CONFIGURED</a>&#160;&#160;&#160;-2</td></tr>
<tr class="memdesc:a9638bd83ff30e7790536ff11138d431b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint not configured.  <a href="ft900__usbd_8h.html#a9638bd83ff30e7790536ff11138d431b">More...</a><br /></td></tr>
<tr class="separator:a9638bd83ff30e7790536ff11138d431b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece6ed7817b9cb53d96fa762b53d2bad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#aece6ed7817b9cb53d96fa762b53d2bad">USBD_ERR_NOT_SUPPORTED</a>&#160;&#160;&#160;-3</td></tr>
<tr class="memdesc:aece6ed7817b9cb53d96fa762b53d2bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation not supported.  <a href="ft900__usbd_8h.html#aece6ed7817b9cb53d96fa762b53d2bad">More...</a><br /></td></tr>
<tr class="separator:aece6ed7817b9cb53d96fa762b53d2bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd97fe44758b75cb5ec71752541c4e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a7fd97fe44758b75cb5ec71752541c4e3">USBD_ERR_RESOURCES</a>&#160;&#160;&#160;-4</td></tr>
<tr class="memdesc:a7fd97fe44758b75cb5ec71752541c4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not enough endpoint resources.  <a href="ft900__usbd_8h.html#a7fd97fe44758b75cb5ec71752541c4e3">More...</a><br /></td></tr>
<tr class="separator:a7fd97fe44758b75cb5ec71752541c4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fbcdd14b252b61003b6b69c1cd6abe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a79fbcdd14b252b61003b6b69c1cd6abe">USBD_ERR_INCOMPLETE</a>&#160;&#160;&#160;-5</td></tr>
<tr class="memdesc:a79fbcdd14b252b61003b6b69c1cd6abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incomplete/interrupted transfer.  <a href="ft900__usbd_8h.html#a79fbcdd14b252b61003b6b69c1cd6abe">More...</a><br /></td></tr>
<tr class="separator:a79fbcdd14b252b61003b6b69c1cd6abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f23a673cfa301d26c06c68783d2700"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a38f23a673cfa301d26c06c68783d2700">USBD_ERR_DISCONNECTED</a>&#160;&#160;&#160;-10</td></tr>
<tr class="memdesc:a38f23a673cfa301d26c06c68783d2700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device not configured by host.  <a href="ft900__usbd_8h.html#a38f23a673cfa301d26c06c68783d2700">More...</a><br /></td></tr>
<tr class="separator:a38f23a673cfa301d26c06c68783d2700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb61a4e8fff2f4624a632a3189cbd3a0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#aeb61a4e8fff2f4624a632a3189cbd3a0">MSB</a>(x)&#160;&#160;&#160;(uint8_t)(((uint16_t)(x) &gt;&gt; 8) &amp; 0x00ff)</td></tr>
<tr class="separator:aeb61a4e8fff2f4624a632a3189cbd3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a3aa6cbadec6a80ab1eae8efd0083d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a34a3aa6cbadec6a80ab1eae8efd0083d">LSB</a>(x)&#160;&#160;&#160;(uint8_t)((uint16_t)(x) &amp; 0x00ff)</td></tr>
<tr class="separator:a34a3aa6cbadec6a80ab1eae8efd0083d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21849edc8e9a97fefd204a4875c27c19"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a21849edc8e9a97fefd204a4875c27c19">USBD_STATE</a> { <br />
&#160;&#160;<a class="el" href="ft900__usbd_8h.html#a21849edc8e9a97fefd204a4875c27c19a35ca8b56bdc46ce0dd7c39400796ba7c">USBD_STATE_NONE</a>
, <a class="el" href="ft900__usbd_8h.html#a21849edc8e9a97fefd204a4875c27c19a01e32e620c7692ea767d99bb4120940b">USBD_STATE_ATTACHED</a>
, <a class="el" href="ft900__usbd_8h.html#a21849edc8e9a97fefd204a4875c27c19a47b9228ad86b300416ed28d2c2b7e5d3">USBD_STATE_POWERED</a>
, <a class="el" href="ft900__usbd_8h.html#a21849edc8e9a97fefd204a4875c27c19a978c707d313eb49b70bc62dfae304048">USBD_STATE_DEFAULT</a>
, <br />
&#160;&#160;<a class="el" href="ft900__usbd_8h.html#a21849edc8e9a97fefd204a4875c27c19a985f06c5505c5684a98954f15701cc9d">USBD_STATE_ADDRESS</a>
, <a class="el" href="ft900__usbd_8h.html#a21849edc8e9a97fefd204a4875c27c19a44c1920b09ea1062ea4d7ac31a846509">USBD_STATE_CONFIGURED</a>
, <a class="el" href="ft900__usbd_8h.html#a21849edc8e9a97fefd204a4875c27c19a74e1d49afc6b25e202cc9e42f595f4ed">USBD_STATE_SUSPENDED</a>
<br />
 }</td></tr>
<tr class="memdesc:a21849edc8e9a97fefd204a4875c27c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB States. USB Spec section 9.1.  <a href="ft900__usbd_8h.html#a21849edc8e9a97fefd204a4875c27c19">More...</a><br /></td></tr>
<tr class="separator:a21849edc8e9a97fefd204a4875c27c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d985b035ef563a7379df0f45216cbc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">USBD_ENDPOINT_NUMBER</a> { <br />
&#160;&#160;<a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbcafb237f4b554c2a4ede70267fb957ff6f">USBD_EP_0</a>
, <a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbcafa67dfae711695e6b95a65b3bd2a3ad6">USBD_EP_1</a>
, <a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbca5457cae16cc990ba13e386ee2c47ac05">USBD_EP_2</a>
, <a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbca9ee5c690ee346f0048c0e9641280e229">USBD_EP_3</a>
, <br />
&#160;&#160;<a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbcaa5cf03f0b1cc500e444c6585e47354cf">USBD_EP_4</a>
, <a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbca1a03b7025063b753ec6e4283e9927828">USBD_EP_5</a>
, <a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbca4d2252b64388a811831a57eb02edb6f1">USBD_EP_6</a>
, <a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbca1f6f684f65e6f2f4f0f8ad542a3a1fd4">USBD_EP_7</a>
<br />
 }</td></tr>
<tr class="memdesc:ab0d985b035ef563a7379df0f45216cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Endpoint Numbers.  <a href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">More...</a><br /></td></tr>
<tr class="separator:ab0d985b035ef563a7379df0f45216cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef975b8ecd5bd4b8071616c74e33cfc5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#aef975b8ecd5bd4b8071616c74e33cfc5">USBD_ENDPOINT_TYPE</a> { <br />
&#160;&#160;<a class="el" href="ft900__usbd_8h.html#aef975b8ecd5bd4b8071616c74e33cfc5a513dbbe31425188c3ceca3f997e200d6">USBD_EP_TYPE_DISABLED</a> = 0
, <a class="el" href="ft900__usbd_8h.html#aef975b8ecd5bd4b8071616c74e33cfc5a36daa79d95ce01ce2aec13034a565e86">USBD_EP_BULK</a> = 1
, <a class="el" href="ft900__usbd_8h.html#aef975b8ecd5bd4b8071616c74e33cfc5a452f562e976b944fb65415d999288d04">USBD_EP_INT</a> = 2
, <a class="el" href="ft900__usbd_8h.html#aef975b8ecd5bd4b8071616c74e33cfc5a70a9da81108de769e9bb0e264bc0a1a9">USBD_EP_ISOC</a> = 3
, <br />
&#160;&#160;<a class="el" href="ft900__usbd_8h.html#aef975b8ecd5bd4b8071616c74e33cfc5a3196d7d5dadf468cdb173f889a22fd55">USBD_EP_CTRL</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:aef975b8ecd5bd4b8071616c74e33cfc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Endpoint Types.  <a href="ft900__usbd_8h.html#aef975b8ecd5bd4b8071616c74e33cfc5">More...</a><br /></td></tr>
<tr class="separator:aef975b8ecd5bd4b8071616c74e33cfc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139ee345e3a7133cca9b3fd1bb95ade8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a139ee345e3a7133cca9b3fd1bb95ade8">USBD_DEVICE_SPEED</a> { <a class="el" href="ft900__usbd_8h.html#a139ee345e3a7133cca9b3fd1bb95ade8a0549585df28ba0c8054381aa686bc6b7">USBD_SPEED_FULL</a>
, <a class="el" href="ft900__usbd_8h.html#a139ee345e3a7133cca9b3fd1bb95ade8a43efe0713518e3f60fe62dd4dc9c70a1">USBD_SPEED_HIGH</a>
 }</td></tr>
<tr class="memdesc:a139ee345e3a7133cca9b3fd1bb95ade8"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Device Speed.  <a href="ft900__usbd_8h.html#a139ee345e3a7133cca9b3fd1bb95ade8">More...</a><br /></td></tr>
<tr class="separator:a139ee345e3a7133cca9b3fd1bb95ade8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d12225cb06f8331d359e6dcca5c70d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a43d12225cb06f8331d359e6dcca5c70d">USBD_ENDPOINT_DIR</a> { <a class="el" href="ft900__usbd_8h.html#a43d12225cb06f8331d359e6dcca5c70da0232295edc22cc7590013ac3986481db">USBD_DIR_OUT</a>
, <a class="el" href="ft900__usbd_8h.html#a43d12225cb06f8331d359e6dcca5c70dabaf0bfce671ce7a8bc07b693011c259d">USBD_DIR_IN</a>
 }</td></tr>
<tr class="memdesc:a43d12225cb06f8331d359e6dcca5c70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Endpoint Direction.  <a href="ft900__usbd_8h.html#a43d12225cb06f8331d359e6dcca5c70d">More...</a><br /></td></tr>
<tr class="separator:a43d12225cb06f8331d359e6dcca5c70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab146eedd60b096ff90ec292c0eaadb60"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#ab146eedd60b096ff90ec292c0eaadb60">USBD_ENDPOINT_SIZE</a> { <br />
&#160;&#160;<a class="el" href="ft900__usbd_8h.html#ab146eedd60b096ff90ec292c0eaadb60a2ce262a2721c8068ac1b601c8d6eebd4">USBD_EP_SIZE_8</a> = 0x00
, <a class="el" href="ft900__usbd_8h.html#ab146eedd60b096ff90ec292c0eaadb60ad58bc53bbdf8993b768864f560a6e6e0">USBD_EP_SIZE_16</a> = 0x01
, <a class="el" href="ft900__usbd_8h.html#ab146eedd60b096ff90ec292c0eaadb60ab2582c447d53f4a80525159c4d75017d">USBD_EP_SIZE_32</a> = 0x02
, <a class="el" href="ft900__usbd_8h.html#ab146eedd60b096ff90ec292c0eaadb60a26b44e3ea687bc96506827aa5720b927">USBD_EP_SIZE_64</a> = 0x03
, <br />
&#160;&#160;<a class="el" href="ft900__usbd_8h.html#ab146eedd60b096ff90ec292c0eaadb60ae7c0078ea88d53f21f7523198710a765">USBD_EP_SIZE_128</a> = 0x04
, <a class="el" href="ft900__usbd_8h.html#ab146eedd60b096ff90ec292c0eaadb60a31d407132cc8fe26b52d054627d15c23">USBD_EP_SIZE_256</a> = 0x05
, <a class="el" href="ft900__usbd_8h.html#ab146eedd60b096ff90ec292c0eaadb60aededff9825bce84633ef1d26315094ec">USBD_EP_SIZE_512</a> = 0x06
, <a class="el" href="ft900__usbd_8h.html#ab146eedd60b096ff90ec292c0eaadb60a8a620e0129cb60078178a4e3d1171e77">USBD_EP_SIZE_1023</a> = 0x07
, <br />
&#160;&#160;<a class="el" href="ft900__usbd_8h.html#ab146eedd60b096ff90ec292c0eaadb60a2a02f7c2d4636deb9b910bbb8c4f7997">USBD_EP_SIZE_1024</a> = 0x07
<br />
 }</td></tr>
<tr class="memdesc:ab146eedd60b096ff90ec292c0eaadb60"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Endpoint Sizes.  <a href="ft900__usbd_8h.html#ab146eedd60b096ff90ec292c0eaadb60">More...</a><br /></td></tr>
<tr class="separator:ab146eedd60b096ff90ec292c0eaadb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac221e531da11da1d0f3c77af322aceea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#ac221e531da11da1d0f3c77af322aceea">USBD_ENDPOINT_DB</a> { <a class="el" href="ft900__usbd_8h.html#ac221e531da11da1d0f3c77af322aceeaac1ccac41ff8e6b11c4ac92be70796929">USBD_DB_OFF</a>
, <a class="el" href="ft900__usbd_8h.html#ac221e531da11da1d0f3c77af322aceeaa8f649271392700d9112425ad4c69697e">USBD_DB_ON</a>
 }</td></tr>
<tr class="memdesc:ac221e531da11da1d0f3c77af322aceea"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Endpoint Double Buffering Enable.  <a href="ft900__usbd_8h.html#ac221e531da11da1d0f3c77af322aceea">More...</a><br /></td></tr>
<tr class="separator:ac221e531da11da1d0f3c77af322aceea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b44dddcb8245ddac5409f9f8eb3a993"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a0b44dddcb8245ddac5409f9f8eb3a993">USBD_TESTMODE_SELECT</a> { <a class="el" href="ft900__usbd_8h.html#a0b44dddcb8245ddac5409f9f8eb3a993a180cfb5084dab34aa49110b26feda901">USBD_TEST_J</a> = 1
, <a class="el" href="ft900__usbd_8h.html#a0b44dddcb8245ddac5409f9f8eb3a993afbf37b0a1ec230680b96e6baacc4c9ff">USBD_TEST_K</a>
, <a class="el" href="ft900__usbd_8h.html#a0b44dddcb8245ddac5409f9f8eb3a993a856e28081ef375ab064080bc2fe7dd6b">USBD_TEST_SE0_NAK</a>
, <a class="el" href="ft900__usbd_8h.html#a0b44dddcb8245ddac5409f9f8eb3a993ab5465b0a6865175a331ef94f72b8ff5d">USBD_TEST_PACKET</a>
 }</td></tr>
<tr class="memdesc:a0b44dddcb8245ddac5409f9f8eb3a993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enums used to select the test modes.For more information refer to Section 7.1.20 of USB2.0 Specification.  <a href="ft900__usbd_8h.html#a0b44dddcb8245ddac5409f9f8eb3a993">More...</a><br /></td></tr>
<tr class="separator:a0b44dddcb8245ddac5409f9f8eb3a993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11e9bb9f6c4eeb3a65da2b3d21c52da"><td class="memItemLeft" align="right" valign="top">typedef int8_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#af11e9bb9f6c4eeb3a65da2b3d21c52da">USBD_request_callback</a>) (<a class="el" href="struct_u_s_b__device__request.html">USB_device_request</a> *req)</td></tr>
<tr class="memdesc:af11e9bb9f6c4eeb3a65da2b3d21c52da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback declaration for Vendor, Class and optionally Standard USB requests.  <a href="ft900__usbd_8h.html#af11e9bb9f6c4eeb3a65da2b3d21c52da">More...</a><br /></td></tr>
<tr class="separator:af11e9bb9f6c4eeb3a65da2b3d21c52da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad679ce47c5af937dd73ce2f36668ea"><td class="memItemLeft" align="right" valign="top">typedef int8_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#afad679ce47c5af937dd73ce2f36668ea">USBD_descriptor_callback</a>) (<a class="el" href="struct_u_s_b__device__request.html">USB_device_request</a> *req, uint8_t **buffer, uint16_t *len)</td></tr>
<tr class="memdesc:afad679ce47c5af937dd73ce2f36668ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback declaration for standard get descriptor requests to obtain descriptor data.  <a href="ft900__usbd_8h.html#afad679ce47c5af937dd73ce2f36668ea">More...</a><br /></td></tr>
<tr class="separator:afad679ce47c5af937dd73ce2f36668ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ded0264d81e3866994bd51454863aa"><td class="memItemLeft" align="right" valign="top">typedef int8_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a60ded0264d81e3866994bd51454863aa">USBD_set_configuration_callback</a>) (<a class="el" href="struct_u_s_b__device__request.html">USB_device_request</a> *req)</td></tr>
<tr class="memdesc:a60ded0264d81e3866994bd51454863aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback declaration for set configuration standard requests.  <a href="ft900__usbd_8h.html#a60ded0264d81e3866994bd51454863aa">More...</a><br /></td></tr>
<tr class="separator:a60ded0264d81e3866994bd51454863aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925b9114c047848abc7c5d8f3138cc7e"><td class="memItemLeft" align="right" valign="top">typedef int8_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a925b9114c047848abc7c5d8f3138cc7e">USBD_set_interface_callback</a>) (<a class="el" href="struct_u_s_b__device__request.html">USB_device_request</a> *req)</td></tr>
<tr class="memdesc:a925b9114c047848abc7c5d8f3138cc7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback declaration for set interface standard requests.  <a href="ft900__usbd_8h.html#a925b9114c047848abc7c5d8f3138cc7e">More...</a><br /></td></tr>
<tr class="separator:a925b9114c047848abc7c5d8f3138cc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11008bd6d5525c5c8afbd929cbd04264"><td class="memItemLeft" align="right" valign="top">typedef int8_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a11008bd6d5525c5c8afbd929cbd04264">USBD_get_interface_callback</a>) (<a class="el" href="struct_u_s_b__device__request.html">USB_device_request</a> *req, uint8_t *val)</td></tr>
<tr class="memdesc:a11008bd6d5525c5c8afbd929cbd04264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback declaration for get interface standard requests.  <a href="ft900__usbd_8h.html#a11008bd6d5525c5c8afbd929cbd04264">More...</a><br /></td></tr>
<tr class="separator:a11008bd6d5525c5c8afbd929cbd04264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab4dd1e33f5f2b786ccf0ec4985680e"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a4ab4dd1e33f5f2b786ccf0ec4985680e">USBD_suspend_callback</a>) (uint8_t status)</td></tr>
<tr class="memdesc:a4ab4dd1e33f5f2b786ccf0ec4985680e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback declaration for a suspend/resume.  <a href="ft900__usbd_8h.html#a4ab4dd1e33f5f2b786ccf0ec4985680e">More...</a><br /></td></tr>
<tr class="separator:a4ab4dd1e33f5f2b786ccf0ec4985680e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa48037ee02f248961d9ec541d0a021"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#acfa48037ee02f248961d9ec541d0a021">USBD_reset_callback</a>) (uint8_t status)</td></tr>
<tr class="memdesc:acfa48037ee02f248961d9ec541d0a021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback declaration for a host reset.  <a href="ft900__usbd_8h.html#acfa48037ee02f248961d9ec541d0a021">More...</a><br /></td></tr>
<tr class="separator:acfa48037ee02f248961d9ec541d0a021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b840ad93d3bd63f846f66cfd4ad3423"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a3b840ad93d3bd63f846f66cfd4ad3423">USBD_sof_callback</a>) (uint16_t frame)</td></tr>
<tr class="memdesc:a3b840ad93d3bd63f846f66cfd4ad3423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback declaration for a SOF event.  <a href="ft900__usbd_8h.html#a3b840ad93d3bd63f846f66cfd4ad3423">More...</a><br /></td></tr>
<tr class="separator:a3b840ad93d3bd63f846f66cfd4ad3423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10fea4f6e1ba81d14841ae9abe3ca0da"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a10fea4f6e1ba81d14841ae9abe3ca0da">USBD_ep_callback</a>) (<a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">USBD_ENDPOINT_NUMBER</a> ep_number)</td></tr>
<tr class="memdesc:a10fea4f6e1ba81d14841ae9abe3ca0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback declaration for transaction completion on endpoint. The endpoint number is passed to the callback to allow the same function to handle multiple endpoints.  <a href="ft900__usbd_8h.html#a10fea4f6e1ba81d14841ae9abe3ca0da">More...</a><br /></td></tr>
<tr class="separator:a10fea4f6e1ba81d14841ae9abe3ca0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6224504443c71e5df852d1045ec4e3"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_u_s_b_d__ctx.html">USBD_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a5e6224504443c71e5df852d1045ec4e3">USBD_ctx</a></td></tr>
<tr class="separator:a5e6224504443c71e5df852d1045ec4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Device endpoint creation support.</h2></td></tr>
<tr class="memitem:aea56c01f97dcc302fc9de8a1f3d714b5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#aea56c01f97dcc302fc9de8a1f3d714b5">USBD_TRANSFER_EX_PART_NORMAL</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:aea56c01f97dcc302fc9de8a1f3d714b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send packet normally.  <a href="ft900__usbd_8h.html#aea56c01f97dcc302fc9de8a1f3d714b5">More...</a><br /></td></tr>
<tr class="separator:aea56c01f97dcc302fc9de8a1f3d714b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899cf15597370e30e5bd07d41a9c85ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a899cf15597370e30e5bd07d41a9c85ce">USBD_TRANSFER_EX_PART_NO_SEND</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a899cf15597370e30e5bd07d41a9c85ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send packet normally.  <a href="ft900__usbd_8h.html#a899cf15597370e30e5bd07d41a9c85ce">More...</a><br /></td></tr>
<tr class="separator:a899cf15597370e30e5bd07d41a9c85ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893a0acd5779eeab9807be19ba481ed3"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a893a0acd5779eeab9807be19ba481ed3">USBD_create_endpoint</a> (<a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">USBD_ENDPOINT_NUMBER</a> ep_number, <a class="el" href="ft900__usbd_8h.html#aef975b8ecd5bd4b8071616c74e33cfc5">USBD_ENDPOINT_TYPE</a> ep_type, <a class="el" href="ft900__usbd_8h.html#a43d12225cb06f8331d359e6dcca5c70d">USBD_ENDPOINT_DIR</a> ep_dir, <a class="el" href="ft900__usbd_8h.html#ab146eedd60b096ff90ec292c0eaadb60">USBD_ENDPOINT_SIZE</a> ep_size, <a class="el" href="ft900__usbd_8h.html#ac221e531da11da1d0f3c77af322aceea">USBD_ENDPOINT_DB</a> ep_db, void *ep_cb)</td></tr>
<tr class="memdesc:a893a0acd5779eeab9807be19ba481ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a USB endpoint.  <a href="ft900__usbd_8h.html#a893a0acd5779eeab9807be19ba481ed3">More...</a><br /></td></tr>
<tr class="separator:a893a0acd5779eeab9807be19ba481ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbe6e7a9f3d7c15388238618429a3da"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#abcbe6e7a9f3d7c15388238618429a3da">USBD_free_endpoint</a> (<a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">USBD_ENDPOINT_NUMBER</a> ep_number)</td></tr>
<tr class="memdesc:abcbe6e7a9f3d7c15388238618429a3da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free USB endpoint.  <a href="ft900__usbd_8h.html#abcbe6e7a9f3d7c15388238618429a3da">More...</a><br /></td></tr>
<tr class="separator:abcbe6e7a9f3d7c15388238618429a3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5fe2d6145f6efd1ff58dd8bf77c4e4"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a7a5fe2d6145f6efd1ff58dd8bf77c4e4">USBD_ep_max_size</a> (<a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">USBD_ENDPOINT_NUMBER</a> ep_number)</td></tr>
<tr class="memdesc:a7a5fe2d6145f6efd1ff58dd8bf77c4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find Max Packet Size of USB endpoint.  <a href="ft900__usbd_8h.html#a7a5fe2d6145f6efd1ff58dd8bf77c4e4">More...</a><br /></td></tr>
<tr class="separator:a7a5fe2d6145f6efd1ff58dd8bf77c4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4485ff25be1ee81ce6e14160426717a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#ae4485ff25be1ee81ce6e14160426717a">USBD_transfer_ex</a> (<a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">USBD_ENDPOINT_NUMBER</a> ep_number, uint8_t *buffer, size_t length, uint8_t part, size_t offset)</td></tr>
<tr class="memdesc:ae4485ff25be1ee81ce6e14160426717a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer data to/from a non-control USB endpoint with options.  <a href="ft900__usbd_8h.html#ae4485ff25be1ee81ce6e14160426717a">More...</a><br /></td></tr>
<tr class="separator:ae4485ff25be1ee81ce6e14160426717a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4238dea9bfd7a98fdd6f018f29a7b067"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a4238dea9bfd7a98fdd6f018f29a7b067">USBD_transfer</a> (<a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">USBD_ENDPOINT_NUMBER</a> ep_number, uint8_t *buffer, size_t length)</td></tr>
<tr class="memdesc:a4238dea9bfd7a98fdd6f018f29a7b067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer data to/from a non-control USB endpoint.  <a href="ft900__usbd_8h.html#a4238dea9bfd7a98fdd6f018f29a7b067">More...</a><br /></td></tr>
<tr class="separator:a4238dea9bfd7a98fdd6f018f29a7b067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe49b688d1767ec00c2e611c76f618b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#afbe49b688d1767ec00c2e611c76f618b">USBD_transfer_ep0</a> (<a class="el" href="ft900__usbd_8h.html#a43d12225cb06f8331d359e6dcca5c70d">USBD_ENDPOINT_DIR</a> dir, uint8_t *buffer, size_t dataLength, size_t requestLength)</td></tr>
<tr class="memdesc:afbe49b688d1767ec00c2e611c76f618b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer data to/from a USB control endpoint.  <a href="ft900__usbd_8h.html#afbe49b688d1767ec00c2e611c76f618b">More...</a><br /></td></tr>
<tr class="separator:afbe49b688d1767ec00c2e611c76f618b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a581cd4e3126f17a43e1ed29fe3c4e"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a48a581cd4e3126f17a43e1ed29fe3c4e">USBD_process</a> (void)</td></tr>
<tr class="memdesc:a48a581cd4e3126f17a43e1ed29fe3c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB process (Deprecated)  <a href="ft900__usbd_8h.html#a48a581cd4e3126f17a43e1ed29fe3c4e">More...</a><br /></td></tr>
<tr class="separator:a48a581cd4e3126f17a43e1ed29fe3c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47aed0a350136f029ecdfdfcc201448"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#ab47aed0a350136f029ecdfdfcc201448">USBD_timer</a> (void)</td></tr>
<tr class="memdesc:ab47aed0a350136f029ecdfdfcc201448"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB timer.  <a href="ft900__usbd_8h.html#ab47aed0a350136f029ecdfdfcc201448">More...</a><br /></td></tr>
<tr class="separator:ab47aed0a350136f029ecdfdfcc201448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417577552966a57e444d08e597a76158"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ft900__usbd_8h.html#a139ee345e3a7133cca9b3fd1bb95ade8">USBD_DEVICE_SPEED</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a417577552966a57e444d08e597a76158">USBD_get_bus_speed</a> (void)</td></tr>
<tr class="memdesc:a417577552966a57e444d08e597a76158"><td class="mdescLeft">&#160;</td><td class="mdescRight">USBD_get_bus_speed.  <a href="ft900__usbd_8h.html#a417577552966a57e444d08e597a76158">More...</a><br /></td></tr>
<tr class="separator:a417577552966a57e444d08e597a76158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ff9ae53fa8ce9e9b812d8c93100182"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a39ff9ae53fa8ce9e9b812d8c93100182">USBD_ep_data_rx_count</a> (<a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">USBD_ENDPOINT_NUMBER</a> ep_number)</td></tr>
<tr class="memdesc:a39ff9ae53fa8ce9e9b812d8c93100182"><td class="mdescLeft">&#160;</td><td class="mdescRight">USBD_ep_data_rx_count.  <a href="ft900__usbd_8h.html#a39ff9ae53fa8ce9e9b812d8c93100182">More...</a><br /></td></tr>
<tr class="separator:a39ff9ae53fa8ce9e9b812d8c93100182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6570d773f3675683c2b6211fe6a42d19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#a6570d773f3675683c2b6211fe6a42d19">USBD_set_test_mode</a> (<a class="el" href="ft900__usbd_8h.html#a0b44dddcb8245ddac5409f9f8eb3a993">USBD_TESTMODE_SELECT</a> test_selector)</td></tr>
<tr class="memdesc:a6570d773f3675683c2b6211fe6a42d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">USBD_set_test_mode.  <a href="ft900__usbd_8h.html#a6570d773f3675683c2b6211fe6a42d19">More...</a><br /></td></tr>
<tr class="separator:a6570d773f3675683c2b6211fe6a42d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4198e2c16ae0c3e45d222d441824e86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbd_8h.html#ae4198e2c16ae0c3e45d222d441824e86">USBD_suspend_device</a> (void)</td></tr>
<tr class="memdesc:ae4198e2c16ae0c3e45d222d441824e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend USB device.  <a href="ft900__usbd_8h.html#ae4198e2c16ae0c3e45d222d441824e86">More...</a><br /></td></tr>
<tr class="separator:ae4198e2c16ae0c3e45d222d441824e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >USB Device API. </p>
<p >This contains USB Device API function definitions, constants and structures which are exposed in the API.</p>
<p >Note that as this is a USB device all transaction nomenclature is from the point of view from the host. If the device sends data to the host then it is called an IN transaction, if it receives data from the host then it is an OUT transaction. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a34a3aa6cbadec6a80ab1eae8efd0083d" name="a34a3aa6cbadec6a80ab1eae8efd0083d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a3aa6cbadec6a80ab1eae8efd0083d">&#9670;&nbsp;</a></span>LSB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LSB</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(uint8_t)((uint16_t)(x) &amp; 0x00ff)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb61a4e8fff2f4624a632a3189cbd3a0" name="aeb61a4e8fff2f4624a632a3189cbd3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb61a4e8fff2f4624a632a3189cbd3a0">&#9670;&nbsp;</a></span>MSB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSB</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(uint8_t)(((uint16_t)(x) &gt;&gt; 8) &amp; 0x00ff)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a38f23a673cfa301d26c06c68783d2700" name="a38f23a673cfa301d26c06c68783d2700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f23a673cfa301d26c06c68783d2700">&#9670;&nbsp;</a></span>USBD_ERR_DISCONNECTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBD_ERR_DISCONNECTED&#160;&#160;&#160;-10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Device not configured by host. </p>
<p >Device physically disconnected from host. </p>

</div>
</div>
<a id="a79fbcdd14b252b61003b6b69c1cd6abe" name="a79fbcdd14b252b61003b6b69c1cd6abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fbcdd14b252b61003b6b69c1cd6abe">&#9670;&nbsp;</a></span>USBD_ERR_INCOMPLETE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBD_ERR_INCOMPLETE&#160;&#160;&#160;-5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Incomplete/interrupted transfer. </p>

</div>
</div>
<a id="ad36fb087126cbf9fc6dfc501e964b51f" name="ad36fb087126cbf9fc6dfc501e964b51f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36fb087126cbf9fc6dfc501e964b51f">&#9670;&nbsp;</a></span>USBD_ERR_INVALID_PARAMETER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBD_ERR_INVALID_PARAMETER&#160;&#160;&#160;-1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalid parameter supplied to API function. </p>

</div>
</div>
<a id="a9638bd83ff30e7790536ff11138d431b" name="a9638bd83ff30e7790536ff11138d431b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9638bd83ff30e7790536ff11138d431b">&#9670;&nbsp;</a></span>USBD_ERR_NOT_CONFIGURED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBD_ERR_NOT_CONFIGURED&#160;&#160;&#160;-2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Endpoint not configured. </p>

</div>
</div>
<a id="aece6ed7817b9cb53d96fa762b53d2bad" name="aece6ed7817b9cb53d96fa762b53d2bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece6ed7817b9cb53d96fa762b53d2bad">&#9670;&nbsp;</a></span>USBD_ERR_NOT_SUPPORTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBD_ERR_NOT_SUPPORTED&#160;&#160;&#160;-3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operation not supported. </p>

</div>
</div>
<a id="a7fd97fe44758b75cb5ec71752541c4e3" name="a7fd97fe44758b75cb5ec71752541c4e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd97fe44758b75cb5ec71752541c4e3">&#9670;&nbsp;</a></span>USBD_ERR_RESOURCES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBD_ERR_RESOURCES&#160;&#160;&#160;-4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not enough endpoint resources. </p>

</div>
</div>
<a id="a72853344bafffd1eff9dd94d81ca3a10" name="a72853344bafffd1eff9dd94d81ca3a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72853344bafffd1eff9dd94d81ca3a10">&#9670;&nbsp;</a></span>USBD_OK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBD_OK&#160;&#160;&#160;0x00</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Success for USB Host function. </p>

</div>
</div>
<a id="a899cf15597370e30e5bd07d41a9c85ce" name="a899cf15597370e30e5bd07d41a9c85ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899cf15597370e30e5bd07d41a9c85ce">&#9670;&nbsp;</a></span>USBD_TRANSFER_EX_PART_NO_SEND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBD_TRANSFER_EX_PART_NO_SEND&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send packet normally. </p>
<p >This will pass data to the transmission buffer but not transmit it unless the data falls on or passes a wMaxPacketSize boundary. If this happens a packet of wMaxPacketSize length will be sent and any remaining data paassed to the transmission buffer. No ZLP will be sent under any circumstances. The last packet sent in the sequence therefore cannot be sent with this method. </p>

</div>
</div>
<a id="aea56c01f97dcc302fc9de8a1f3d714b5" name="aea56c01f97dcc302fc9de8a1f3d714b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea56c01f97dcc302fc9de8a1f3d714b5">&#9670;&nbsp;</a></span>USBD_TRANSFER_EX_PART_NORMAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBD_TRANSFER_EX_PART_NORMAL&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send packet normally. </p>
<p >This will send the data passed immediately, copying it into the transmission buffer and sending it. If the length falls on a wMaxPacketSize boundary then a ZLP will be sent after the packet (this will not happen for interrupt endpoints). </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a5e6224504443c71e5df852d1045ec4e3" name="a5e6224504443c71e5df852d1045ec4e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6224504443c71e5df852d1045ec4e3">&#9670;&nbsp;</a></span>USBD_ctx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_u_s_b_d__ctx.html">USBD_ctx</a> <a class="el" href="struct_u_s_b_d__ctx.html">USBD_ctx</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afad679ce47c5af937dd73ce2f36668ea" name="afad679ce47c5af937dd73ce2f36668ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad679ce47c5af937dd73ce2f36668ea">&#9670;&nbsp;</a></span>USBD_descriptor_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USBD_descriptor_callback</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback declaration for standard get descriptor requests to obtain descriptor data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>USB request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Data buffer containing descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBD_OK if the request was handled successfully; any other return value (such as FT9XX_FAILED) causes the USB driver to stall the control endpoints. </dd></dl>

</div>
</div>
<a id="a10fea4f6e1ba81d14841ae9abe3ca0da" name="a10fea4f6e1ba81d14841ae9abe3ca0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10fea4f6e1ba81d14841ae9abe3ca0da">&#9670;&nbsp;</a></span>USBD_ep_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USBD_ep_callback</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback declaration for transaction completion on endpoint. The endpoint number is passed to the callback to allow the same function to handle multiple endpoints. </p>

</div>
</div>
<a id="a11008bd6d5525c5c8afbd929cbd04264" name="a11008bd6d5525c5c8afbd929cbd04264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11008bd6d5525c5c8afbd929cbd04264">&#9670;&nbsp;</a></span>USBD_get_interface_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USBD_get_interface_callback</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback declaration for get interface standard requests. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>USB request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Status of USB request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBD_OK if the request is valid; any other return value (such as FT9XX_FAILED) causes the USB driver to stall the control endpoints. </dd></dl>

</div>
</div>
<a id="af11e9bb9f6c4eeb3a65da2b3d21c52da" name="af11e9bb9f6c4eeb3a65da2b3d21c52da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af11e9bb9f6c4eeb3a65da2b3d21c52da">&#9670;&nbsp;</a></span>USBD_request_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USBD_request_callback</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback declaration for Vendor, Class and optionally Standard USB requests. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>USB request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBD_OK if the request was handled successfully; any other return value (such as FT9XX_FAILED) causes the USB driver to stall the control endpoints. </dd></dl>

</div>
</div>
<a id="acfa48037ee02f248961d9ec541d0a021" name="acfa48037ee02f248961d9ec541d0a021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa48037ee02f248961d9ec541d0a021">&#9670;&nbsp;</a></span>USBD_reset_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USBD_reset_callback</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback declaration for a host reset. </p>

</div>
</div>
<a id="a60ded0264d81e3866994bd51454863aa" name="a60ded0264d81e3866994bd51454863aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ded0264d81e3866994bd51454863aa">&#9670;&nbsp;</a></span>USBD_set_configuration_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USBD_set_configuration_callback</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback declaration for set configuration standard requests. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>USB request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBD_OK if the request is valid; any other return value (such as FT9XX_FAILED) causes the USB driver to stall the control endpoints. </dd></dl>

</div>
</div>
<a id="a925b9114c047848abc7c5d8f3138cc7e" name="a925b9114c047848abc7c5d8f3138cc7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925b9114c047848abc7c5d8f3138cc7e">&#9670;&nbsp;</a></span>USBD_set_interface_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USBD_set_interface_callback</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback declaration for set interface standard requests. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>USB request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBD_OK if the request is valid; any other return value (such as FT9XX_FAILED) causes the USB driver to stall the control endpoints. </dd></dl>

</div>
</div>
<a id="a3b840ad93d3bd63f846f66cfd4ad3423" name="a3b840ad93d3bd63f846f66cfd4ad3423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b840ad93d3bd63f846f66cfd4ad3423">&#9670;&nbsp;</a></span>USBD_sof_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USBD_sof_callback</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback declaration for a SOF event. </p>

</div>
</div>
<a id="a4ab4dd1e33f5f2b786ccf0ec4985680e" name="a4ab4dd1e33f5f2b786ccf0ec4985680e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab4dd1e33f5f2b786ccf0ec4985680e">&#9670;&nbsp;</a></span>USBD_suspend_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USBD_suspend_callback</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback declaration for a suspend/resume. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a139ee345e3a7133cca9b3fd1bb95ade8" name="a139ee345e3a7133cca9b3fd1bb95ade8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139ee345e3a7133cca9b3fd1bb95ade8">&#9670;&nbsp;</a></span>USBD_DEVICE_SPEED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ft900__usbd_8h.html#a139ee345e3a7133cca9b3fd1bb95ade8">USBD_DEVICE_SPEED</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB Device Speed. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a139ee345e3a7133cca9b3fd1bb95ade8a0549585df28ba0c8054381aa686bc6b7" name="a139ee345e3a7133cca9b3fd1bb95ade8a0549585df28ba0c8054381aa686bc6b7"></a>USBD_SPEED_FULL&#160;</td><td class="fielddoc"><p >Full speed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a139ee345e3a7133cca9b3fd1bb95ade8a43efe0713518e3f60fe62dd4dc9c70a1" name="a139ee345e3a7133cca9b3fd1bb95ade8a43efe0713518e3f60fe62dd4dc9c70a1"></a>USBD_SPEED_HIGH&#160;</td><td class="fielddoc"><p >High speed. </p>
</td></tr>
</table>

</div>
</div>
<a id="ac221e531da11da1d0f3c77af322aceea" name="ac221e531da11da1d0f3c77af322aceea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac221e531da11da1d0f3c77af322aceea">&#9670;&nbsp;</a></span>USBD_ENDPOINT_DB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ft900__usbd_8h.html#ac221e531da11da1d0f3c77af322aceea">USBD_ENDPOINT_DB</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB Endpoint Double Buffering Enable. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac221e531da11da1d0f3c77af322aceeaac1ccac41ff8e6b11c4ac92be70796929" name="ac221e531da11da1d0f3c77af322aceeaac1ccac41ff8e6b11c4ac92be70796929"></a>USBD_DB_OFF&#160;</td><td class="fielddoc"><p >Disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac221e531da11da1d0f3c77af322aceeaa8f649271392700d9112425ad4c69697e" name="ac221e531da11da1d0f3c77af322aceeaa8f649271392700d9112425ad4c69697e"></a>USBD_DB_ON&#160;</td><td class="fielddoc"><p >Enabled. </p>
</td></tr>
</table>

</div>
</div>
<a id="a43d12225cb06f8331d359e6dcca5c70d" name="a43d12225cb06f8331d359e6dcca5c70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d12225cb06f8331d359e6dcca5c70d">&#9670;&nbsp;</a></span>USBD_ENDPOINT_DIR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ft900__usbd_8h.html#a43d12225cb06f8331d359e6dcca5c70d">USBD_ENDPOINT_DIR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB Endpoint Direction. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a43d12225cb06f8331d359e6dcca5c70da0232295edc22cc7590013ac3986481db" name="a43d12225cb06f8331d359e6dcca5c70da0232295edc22cc7590013ac3986481db"></a>USBD_DIR_OUT&#160;</td><td class="fielddoc"><p >Direction host to device. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43d12225cb06f8331d359e6dcca5c70dabaf0bfce671ce7a8bc07b693011c259d" name="a43d12225cb06f8331d359e6dcca5c70dabaf0bfce671ce7a8bc07b693011c259d"></a>USBD_DIR_IN&#160;</td><td class="fielddoc"><p >Direction device to host. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab0d985b035ef563a7379df0f45216cbc" name="ab0d985b035ef563a7379df0f45216cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0d985b035ef563a7379df0f45216cbc">&#9670;&nbsp;</a></span>USBD_ENDPOINT_NUMBER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">USBD_ENDPOINT_NUMBER</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB Endpoint Numbers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab0d985b035ef563a7379df0f45216cbcafb237f4b554c2a4ede70267fb957ff6f" name="ab0d985b035ef563a7379df0f45216cbcafb237f4b554c2a4ede70267fb957ff6f"></a>USBD_EP_0&#160;</td><td class="fielddoc"><p >Endpoint 0 (Control Endpoint) </p>
</td></tr>
<tr><td class="fieldname"><a id="ab0d985b035ef563a7379df0f45216cbcafa67dfae711695e6b95a65b3bd2a3ad6" name="ab0d985b035ef563a7379df0f45216cbcafa67dfae711695e6b95a65b3bd2a3ad6"></a>USBD_EP_1&#160;</td><td class="fielddoc"><p >Endpoint 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab0d985b035ef563a7379df0f45216cbca5457cae16cc990ba13e386ee2c47ac05" name="ab0d985b035ef563a7379df0f45216cbca5457cae16cc990ba13e386ee2c47ac05"></a>USBD_EP_2&#160;</td><td class="fielddoc"><p >Endpoint 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab0d985b035ef563a7379df0f45216cbca9ee5c690ee346f0048c0e9641280e229" name="ab0d985b035ef563a7379df0f45216cbca9ee5c690ee346f0048c0e9641280e229"></a>USBD_EP_3&#160;</td><td class="fielddoc"><p >Endpoint 3. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab0d985b035ef563a7379df0f45216cbcaa5cf03f0b1cc500e444c6585e47354cf" name="ab0d985b035ef563a7379df0f45216cbcaa5cf03f0b1cc500e444c6585e47354cf"></a>USBD_EP_4&#160;</td><td class="fielddoc"><p >Endpoint 4. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab0d985b035ef563a7379df0f45216cbca1a03b7025063b753ec6e4283e9927828" name="ab0d985b035ef563a7379df0f45216cbca1a03b7025063b753ec6e4283e9927828"></a>USBD_EP_5&#160;</td><td class="fielddoc"><p >Endpoint 5. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab0d985b035ef563a7379df0f45216cbca4d2252b64388a811831a57eb02edb6f1" name="ab0d985b035ef563a7379df0f45216cbca4d2252b64388a811831a57eb02edb6f1"></a>USBD_EP_6&#160;</td><td class="fielddoc"><p >Endpoint 6. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab0d985b035ef563a7379df0f45216cbca1f6f684f65e6f2f4f0f8ad542a3a1fd4" name="ab0d985b035ef563a7379df0f45216cbca1f6f684f65e6f2f4f0f8ad542a3a1fd4"></a>USBD_EP_7&#160;</td><td class="fielddoc"><p >Endpoint 7. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab146eedd60b096ff90ec292c0eaadb60" name="ab146eedd60b096ff90ec292c0eaadb60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab146eedd60b096ff90ec292c0eaadb60">&#9670;&nbsp;</a></span>USBD_ENDPOINT_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ft900__usbd_8h.html#ab146eedd60b096ff90ec292c0eaadb60">USBD_ENDPOINT_SIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB Endpoint Sizes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab146eedd60b096ff90ec292c0eaadb60a2ce262a2721c8068ac1b601c8d6eebd4" name="ab146eedd60b096ff90ec292c0eaadb60a2ce262a2721c8068ac1b601c8d6eebd4"></a>USBD_EP_SIZE_8&#160;</td><td class="fielddoc"><p >8 Bytes </p>
</td></tr>
<tr><td class="fieldname"><a id="ab146eedd60b096ff90ec292c0eaadb60ad58bc53bbdf8993b768864f560a6e6e0" name="ab146eedd60b096ff90ec292c0eaadb60ad58bc53bbdf8993b768864f560a6e6e0"></a>USBD_EP_SIZE_16&#160;</td><td class="fielddoc"><p >16 Bytes </p>
</td></tr>
<tr><td class="fieldname"><a id="ab146eedd60b096ff90ec292c0eaadb60ab2582c447d53f4a80525159c4d75017d" name="ab146eedd60b096ff90ec292c0eaadb60ab2582c447d53f4a80525159c4d75017d"></a>USBD_EP_SIZE_32&#160;</td><td class="fielddoc"><p >32 Bytes </p>
</td></tr>
<tr><td class="fieldname"><a id="ab146eedd60b096ff90ec292c0eaadb60a26b44e3ea687bc96506827aa5720b927" name="ab146eedd60b096ff90ec292c0eaadb60a26b44e3ea687bc96506827aa5720b927"></a>USBD_EP_SIZE_64&#160;</td><td class="fielddoc"><p >64 Bytes </p>
</td></tr>
<tr><td class="fieldname"><a id="ab146eedd60b096ff90ec292c0eaadb60ae7c0078ea88d53f21f7523198710a765" name="ab146eedd60b096ff90ec292c0eaadb60ae7c0078ea88d53f21f7523198710a765"></a>USBD_EP_SIZE_128&#160;</td><td class="fielddoc"><p >128 Bytes. Only available on High Speed endpoints. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab146eedd60b096ff90ec292c0eaadb60a31d407132cc8fe26b52d054627d15c23" name="ab146eedd60b096ff90ec292c0eaadb60a31d407132cc8fe26b52d054627d15c23"></a>USBD_EP_SIZE_256&#160;</td><td class="fielddoc"><p >256 Bytes. Only available on High Speed endpoints. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab146eedd60b096ff90ec292c0eaadb60aededff9825bce84633ef1d26315094ec" name="ab146eedd60b096ff90ec292c0eaadb60aededff9825bce84633ef1d26315094ec"></a>USBD_EP_SIZE_512&#160;</td><td class="fielddoc"><p >512 Bytes. Only available on High Speed endpoints. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab146eedd60b096ff90ec292c0eaadb60a8a620e0129cb60078178a4e3d1171e77" name="ab146eedd60b096ff90ec292c0eaadb60a8a620e0129cb60078178a4e3d1171e77"></a>USBD_EP_SIZE_1023&#160;</td><td class="fielddoc"><p >1023 Bytes. Only available on Full Speed ISO endpoints. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab146eedd60b096ff90ec292c0eaadb60a2a02f7c2d4636deb9b910bbb8c4f7997" name="ab146eedd60b096ff90ec292c0eaadb60a2a02f7c2d4636deb9b910bbb8c4f7997"></a>USBD_EP_SIZE_1024&#160;</td><td class="fielddoc"><p >1024 Bytes. Only available on High Speed ISO and Interrupt endpoints. </p>
</td></tr>
</table>

</div>
</div>
<a id="aef975b8ecd5bd4b8071616c74e33cfc5" name="aef975b8ecd5bd4b8071616c74e33cfc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef975b8ecd5bd4b8071616c74e33cfc5">&#9670;&nbsp;</a></span>USBD_ENDPOINT_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ft900__usbd_8h.html#aef975b8ecd5bd4b8071616c74e33cfc5">USBD_ENDPOINT_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB Endpoint Types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aef975b8ecd5bd4b8071616c74e33cfc5a513dbbe31425188c3ceca3f997e200d6" name="aef975b8ecd5bd4b8071616c74e33cfc5a513dbbe31425188c3ceca3f997e200d6"></a>USBD_EP_TYPE_DISABLED&#160;</td><td class="fielddoc"><p >Disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="aef975b8ecd5bd4b8071616c74e33cfc5a36daa79d95ce01ce2aec13034a565e86" name="aef975b8ecd5bd4b8071616c74e33cfc5a36daa79d95ce01ce2aec13034a565e86"></a>USBD_EP_BULK&#160;</td><td class="fielddoc"><p >Bulk Endpoint. </p>
</td></tr>
<tr><td class="fieldname"><a id="aef975b8ecd5bd4b8071616c74e33cfc5a452f562e976b944fb65415d999288d04" name="aef975b8ecd5bd4b8071616c74e33cfc5a452f562e976b944fb65415d999288d04"></a>USBD_EP_INT&#160;</td><td class="fielddoc"><p >Interrupt Endpoint. </p>
</td></tr>
<tr><td class="fieldname"><a id="aef975b8ecd5bd4b8071616c74e33cfc5a70a9da81108de769e9bb0e264bc0a1a9" name="aef975b8ecd5bd4b8071616c74e33cfc5a70a9da81108de769e9bb0e264bc0a1a9"></a>USBD_EP_ISOC&#160;</td><td class="fielddoc"><p >Isochronous Endpoint. </p>
</td></tr>
<tr><td class="fieldname"><a id="aef975b8ecd5bd4b8071616c74e33cfc5a3196d7d5dadf468cdb173f889a22fd55" name="aef975b8ecd5bd4b8071616c74e33cfc5a3196d7d5dadf468cdb173f889a22fd55"></a>USBD_EP_CTRL&#160;</td><td class="fielddoc"><p >Control Endpoint. </p>
</td></tr>
</table>

</div>
</div>
<a id="a21849edc8e9a97fefd204a4875c27c19" name="a21849edc8e9a97fefd204a4875c27c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21849edc8e9a97fefd204a4875c27c19">&#9670;&nbsp;</a></span>USBD_STATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ft900__usbd_8h.html#a21849edc8e9a97fefd204a4875c27c19">USBD_STATE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB States. USB Spec section 9.1. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a21849edc8e9a97fefd204a4875c27c19a35ca8b56bdc46ce0dd7c39400796ba7c" name="a21849edc8e9a97fefd204a4875c27c19a35ca8b56bdc46ce0dd7c39400796ba7c"></a>USBD_STATE_NONE&#160;</td><td class="fielddoc"><p >Device is not attached. </p>
</td></tr>
<tr><td class="fieldname"><a id="a21849edc8e9a97fefd204a4875c27c19a01e32e620c7692ea767d99bb4120940b" name="a21849edc8e9a97fefd204a4875c27c19a01e32e620c7692ea767d99bb4120940b"></a>USBD_STATE_ATTACHED&#160;</td><td class="fielddoc"><p >Device is attached to USB. </p>
</td></tr>
<tr><td class="fieldname"><a id="a21849edc8e9a97fefd204a4875c27c19a47b9228ad86b300416ed28d2c2b7e5d3" name="a21849edc8e9a97fefd204a4875c27c19a47b9228ad86b300416ed28d2c2b7e5d3"></a>USBD_STATE_POWERED&#160;</td><td class="fielddoc"><p >Device is attached and powered. </p>
</td></tr>
<tr><td class="fieldname"><a id="a21849edc8e9a97fefd204a4875c27c19a978c707d313eb49b70bc62dfae304048" name="a21849edc8e9a97fefd204a4875c27c19a978c707d313eb49b70bc62dfae304048"></a>USBD_STATE_DEFAULT&#160;</td><td class="fielddoc"><p >Device is attached, has power and has been reset. </p>
</td></tr>
<tr><td class="fieldname"><a id="a21849edc8e9a97fefd204a4875c27c19a985f06c5505c5684a98954f15701cc9d" name="a21849edc8e9a97fefd204a4875c27c19a985f06c5505c5684a98954f15701cc9d"></a>USBD_STATE_ADDRESS&#160;</td><td class="fielddoc"><p >Unique device address has not been set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a21849edc8e9a97fefd204a4875c27c19a44c1920b09ea1062ea4d7ac31a846509" name="a21849edc8e9a97fefd204a4875c27c19a44c1920b09ea1062ea4d7ac31a846509"></a>USBD_STATE_CONFIGURED&#160;</td><td class="fielddoc"><p >Unique device address is now assigned. Device can be used by host. </p>
</td></tr>
<tr><td class="fieldname"><a id="a21849edc8e9a97fefd204a4875c27c19a74e1d49afc6b25e202cc9e42f595f4ed" name="a21849edc8e9a97fefd204a4875c27c19a74e1d49afc6b25e202cc9e42f595f4ed"></a>USBD_STATE_SUSPENDED&#160;</td><td class="fielddoc"><p >Device has been suspended. </p>
</td></tr>
</table>

</div>
</div>
<a id="a0b44dddcb8245ddac5409f9f8eb3a993" name="a0b44dddcb8245ddac5409f9f8eb3a993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b44dddcb8245ddac5409f9f8eb3a993">&#9670;&nbsp;</a></span>USBD_TESTMODE_SELECT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ft900__usbd_8h.html#a0b44dddcb8245ddac5409f9f8eb3a993">USBD_TESTMODE_SELECT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enums used to select the test modes.For more information refer to Section 7.1.20 of USB2.0 Specification. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0b44dddcb8245ddac5409f9f8eb3a993a180cfb5084dab34aa49110b26feda901" name="a0b44dddcb8245ddac5409f9f8eb3a993a180cfb5084dab34aa49110b26feda901"></a>USBD_TEST_J&#160;</td><td class="fielddoc"><p >Test mode Test_J </p>
</td></tr>
<tr><td class="fieldname"><a id="a0b44dddcb8245ddac5409f9f8eb3a993afbf37b0a1ec230680b96e6baacc4c9ff" name="a0b44dddcb8245ddac5409f9f8eb3a993afbf37b0a1ec230680b96e6baacc4c9ff"></a>USBD_TEST_K&#160;</td><td class="fielddoc"><p >Test mode Test_K </p>
</td></tr>
<tr><td class="fieldname"><a id="a0b44dddcb8245ddac5409f9f8eb3a993a856e28081ef375ab064080bc2fe7dd6b" name="a0b44dddcb8245ddac5409f9f8eb3a993a856e28081ef375ab064080bc2fe7dd6b"></a>USBD_TEST_SE0_NAK&#160;</td><td class="fielddoc"><p >Test mode Test_SE0_NAK </p>
</td></tr>
<tr><td class="fieldname"><a id="a0b44dddcb8245ddac5409f9f8eb3a993ab5465b0a6865175a331ef94f72b8ff5d" name="a0b44dddcb8245ddac5409f9f8eb3a993ab5465b0a6865175a331ef94f72b8ff5d"></a>USBD_TEST_PACKET&#160;</td><td class="fielddoc"><p >Test mode Test_PACKET </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acf6119c3e3bd9b1a486ade5561f8b4df" name="acf6119c3e3bd9b1a486ade5561f8b4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6119c3e3bd9b1a486ade5561f8b4df">&#9670;&nbsp;</a></span>USBD_attach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_attach </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach USB hardware. </p>
<p >Attaches the USB device to the USB host after a USB_detach call. </p>

</div>
</div>
<a id="a9b972e52e9a936df8760d9a7a5ae89ed" name="a9b972e52e9a936df8760d9a7a5ae89ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b972e52e9a936df8760d9a7a5ae89ed">&#9670;&nbsp;</a></span>USBD_clear_endpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBD_clear_endpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">USBD_ENDPOINT_NUMBER</a>&#160;</td>
          <td class="paramname"><em>ep_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears endpoint stall. </p>
<p >Clears a stall from the specified endpoint. The default standard request handler will call this function for a CLEAR_FEATURE endpoint request. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_number</td><td>USB endpoint number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBD_OK if successful USBD_ERR_NOT_CONFIGURED if the endpoint is not configured. USBD_ERR_INVALID_PARAMETER if the endpoint number is not allowed. </dd></dl>

</div>
</div>
<a id="ad84490fa8bbba171200b9fbdfca1e9d2" name="ad84490fa8bbba171200b9fbdfca1e9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84490fa8bbba171200b9fbdfca1e9d2">&#9670;&nbsp;</a></span>USBD_clear_remote_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_clear_remote_wakeup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear USB remote wakeup feature status. </p>

</div>
</div>
<a id="af71f8a4b3db728e169ed04383392b506" name="af71f8a4b3db728e169ed04383392b506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71f8a4b3db728e169ed04383392b506">&#9670;&nbsp;</a></span>USBD_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBD_connect </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to a USB host. </p>
<p >Checks the VBUS detect line for a host connected and proceed to allow the device to negotiate a connection to the host. </p><dl class="section return"><dt>Returns</dt><dd>USBD_OK on success.<br  />
 USBD_ERR_INVALID_PARAMETER if req is invalid. </dd></dl>

</div>
</div>
<a id="a893a0acd5779eeab9807be19ba481ed3" name="a893a0acd5779eeab9807be19ba481ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a893a0acd5779eeab9807be19ba481ed3">&#9670;&nbsp;</a></span>USBD_create_endpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBD_create_endpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">USBD_ENDPOINT_NUMBER</a>&#160;</td>
          <td class="paramname"><em>ep_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ft900__usbd_8h.html#aef975b8ecd5bd4b8071616c74e33cfc5">USBD_ENDPOINT_TYPE</a>&#160;</td>
          <td class="paramname"><em>ep_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ft900__usbd_8h.html#a43d12225cb06f8331d359e6dcca5c70d">USBD_ENDPOINT_DIR</a>&#160;</td>
          <td class="paramname"><em>ep_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ft900__usbd_8h.html#ab146eedd60b096ff90ec292c0eaadb60">USBD_ENDPOINT_SIZE</a>&#160;</td>
          <td class="paramname"><em>ep_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ft900__usbd_8h.html#ac221e531da11da1d0f3c77af322aceea">USBD_ENDPOINT_DB</a>&#160;</td>
          <td class="paramname"><em>ep_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ep_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a USB endpoint. </p>
<p >Creates an endpoint with the requested properties.<br  />
 There is a total of 4 kB of RAM for FT90x Rev B, 6KB for FT90x Rev C and 8KB for FT930. This total RAM is for all the IN and OUT endpoints. Therefore the total max packet for all IN endpoints and OUT endpoints must be less than this figure. If double buffering is employed for an endpoint then it will use twice the amount of RAM. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_number</td><td>USB endpoint number. (N/A for control endpoints). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_type</td><td>USB endpoint type: BULK, ISO or INT. (N/A for control endpoints). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_dir</td><td>Endpoint direction, In or Out. ( </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_size</td><td>USB endpoint max packet size in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_db</td><td>USB endpoint double buffering enable. (N/A for control endpoints). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_cb</td><td>Deprecated: Callback function for this endpoint. This function was called when an event concerned with the endpoint has occurred. This was used for receiving notification of transaction to or from the endpoint heralding the availability of data (OUT endpoints) or the completion of a transmission of data (IN endpoints). However, the <a class="el" href="ft900__usbd_8h.html#a0c3e39b942284dede1a29d2a5037af56" title="Get USB endpoint buffer status.">USBD_ep_buffer_full()</a> function can be polled to determine the same status if callbacks are inappropriate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBD_OK if successful. USBD_ERR_NOT_SUPPORTED if an endpoint higher than the maximum number of endpoints is requested. USBD_ERR_INVALID_PARAMETER if an illegal endpoint size is requested. USBD_ERR_RESOURCES if there is not enough endpoint RAM for the endpoint size requested. </dd></dl>

</div>
</div>
<a id="a577c02a3d1820b01494f9e8492a8ac3b" name="a577c02a3d1820b01494f9e8492a8ac3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577c02a3d1820b01494f9e8492a8ac3b">&#9670;&nbsp;</a></span>USBD_detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_detach </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach USB hardware. </p>
<p >Detaches the USB device from the USB host. This will look like device disconnect to the host and it will act like the device is removed. </p>

</div>
</div>
<a id="a0c3e39b942284dede1a29d2a5037af56" name="a0c3e39b942284dede1a29d2a5037af56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c3e39b942284dede1a29d2a5037af56">&#9670;&nbsp;</a></span>USBD_ep_buffer_full()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBD_ep_buffer_full </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">USBD_ENDPOINT_NUMBER</a>&#160;</td>
          <td class="paramname"><em>ep_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get USB endpoint buffer status. </p>
<p >Returns the current buffer status of an endpoint using the SELECT_ENDPOINT call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_number</td><td>USB endpoint number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current state of the endpoint buffer. TRUE if full, FALSE if empty. </dd></dl>

</div>
</div>
<a id="a39ff9ae53fa8ce9e9b812d8c93100182" name="a39ff9ae53fa8ce9e9b812d8c93100182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ff9ae53fa8ce9e9b812d8c93100182">&#9670;&nbsp;</a></span>USBD_ep_data_rx_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t USBD_ep_data_rx_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">USBD_ENDPOINT_NUMBER</a>&#160;</td>
          <td class="paramname"><em>ep_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USBD_ep_data_rx_count. </p>
<p >Provides the size of the OUT packet that is yet to be read </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_number</td><td>USB endpoint number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually received. USBD_ERR_NOT_CONFIGURED if endpoint is not configured. </dd></dl>

</div>
</div>
<a id="a7a5fe2d6145f6efd1ff58dd8bf77c4e4" name="a7a5fe2d6145f6efd1ff58dd8bf77c4e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5fe2d6145f6efd1ff58dd8bf77c4e4">&#9670;&nbsp;</a></span>USBD_ep_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t USBD_ep_max_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">USBD_ENDPOINT_NUMBER</a>&#160;</td>
          <td class="paramname"><em>ep_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find Max Packet Size of USB endpoint. </p>
<p >Return the maximum number of bytes which can be sent or received in a single USB packets for an endpoint. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_number</td><td>USB endpoint to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes if successful USBD_ERR_NOT_CONFIGURED if the endpoint is not configured. USBD_ERR_INVALID_PARAMETER if the endpoint number is not allowed. </dd></dl>

</div>
</div>
<a id="aa0d269eb6fcb0ef90d9cc2b3d7ec1dd3" name="aa0d269eb6fcb0ef90d9cc2b3d7ec1dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d269eb6fcb0ef90d9cc2b3d7ec1dd3">&#9670;&nbsp;</a></span>USBD_finalise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_finalise </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalise USB hardware. </p>
<p >Releases any resources associated with the USB driver and disables the hardware. </p>

</div>
</div>
<a id="abcbe6e7a9f3d7c15388238618429a3da" name="abcbe6e7a9f3d7c15388238618429a3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcbe6e7a9f3d7c15388238618429a3da">&#9670;&nbsp;</a></span>USBD_free_endpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBD_free_endpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">USBD_ENDPOINT_NUMBER</a>&#160;</td>
          <td class="paramname"><em>ep_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free USB endpoint. </p>
<p >Disable and free the specified endpoint. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_number</td><td>USB endpoint to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBD_OK if successful USBD_ERR_NOT_CONFIGURED if the endpoint is not configured. USBD_ERR_INVALID_PARAMETER if the endpoint number is not allowed. </dd></dl>

</div>
</div>
<a id="a417577552966a57e444d08e597a76158" name="a417577552966a57e444d08e597a76158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417577552966a57e444d08e597a76158">&#9670;&nbsp;</a></span>USBD_get_bus_speed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ft900__usbd_8h.html#a139ee345e3a7133cca9b3fd1bb95ade8">USBD_DEVICE_SPEED</a> USBD_get_bus_speed </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USBD_get_bus_speed. </p>
<p >To be called to get the current USB bus speed at which USBD operates </p><dl class="section return"><dt>Returns</dt><dd>returns Full or High Speed. </dd></dl>

</div>
</div>
<a id="ab8a0ef2de2d0e76f0f371e9f81e6ae13" name="ab8a0ef2de2d0e76f0f371e9f81e6ae13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a0ef2de2d0e76f0f371e9f81e6ae13">&#9670;&nbsp;</a></span>USBD_get_ep_stalled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBD_get_ep_stalled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">USBD_ENDPOINT_NUMBER</a>&#160;</td>
          <td class="paramname"><em>ep_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get USB endpoint stall status. </p>
<p >Returns the current stall status of an endpoint using the SELECT_ENDPOINT call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_number</td><td>USB endpoint number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current stall state of the endpoint. &gt;0 if stalled, zero if not stalled. USBD_ERR_NOT_CONFIGURED if the endpoint is not configured. USBD_ERR_INVALID_PARAMETER if the endpoint number is not allowed. </dd></dl>

</div>
</div>
<a id="a2708e6c69d50792ffd53dfe4a3ee9ded" name="a2708e6c69d50792ffd53dfe4a3ee9ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2708e6c69d50792ffd53dfe4a3ee9ded">&#9670;&nbsp;</a></span>USBD_get_remote_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBD_get_remote_wakeup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get USB remote wakeup feature status. </p>
<p >Returns the current feature status of remote wakeup. </p><dl class="section return"><dt>Returns</dt><dd>Current remote wakeup feature status. TRUE if enabled, FALSE if not enabled. </dd></dl>

</div>
</div>
<a id="ada576592480413ec6635cbf598980e49" name="ada576592480413ec6635cbf598980e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada576592480413ec6635cbf598980e49">&#9670;&nbsp;</a></span>USBD_get_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ft900__usbd_8h.html#a21849edc8e9a97fefd204a4875c27c19">USBD_STATE</a> USBD_get_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get USB state. </p>
<p >Returns the current state of the current USB device. Please refer to section 9.1 of the USB 2.0 spec for more information. </p><dl class="section return"><dt>Returns</dt><dd>Current state of the current USB device. </dd></dl>

</div>
</div>
<a id="a7008036eb3ba34bbf12a8dba8f9d0fba" name="a7008036eb3ba34bbf12a8dba8f9d0fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7008036eb3ba34bbf12a8dba8f9d0fba">&#9670;&nbsp;</a></span>USBD_initialise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_initialise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_d__ctx.html">USBD_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise USB hardware. </p>
<p >Performs a software reset and intialises the USB hardware.<br  />
 The <a class="el" href="struct_u_s_b_d__ctx.html" title="Struct containing callback functions for the USB upper layer driver and callback functions for USB su...">USBD_ctx</a> contains function pointers to the protocol layer handling USB requests. Appropriate USB requests will be routed to the correct handler, whether that be Standard, Class or Vendor requests. A device may not need a handler for Vendor or Class requests depending on the device configuration.<br  />
 Optional function pointers are also available for USB suspend and resume callbacks and bus resets issued by the host.<br  />
 This function MUST be called prior to any further call to the USB functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>USB context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a8749e74bcaae4bfb7d6c241d4313b6" name="a2a8749e74bcaae4bfb7d6c241d4313b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8749e74bcaae4bfb7d6c241d4313b6">&#9670;&nbsp;</a></span>USBD_is_connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBD_is_connected </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the device is connected to a host (or external power source). </p>
<p >Checks the VBUS detect line for a host connected. </p>

</div>
</div>
<a id="a48a581cd4e3126f17a43e1ed29fe3c4e" name="a48a581cd4e3126f17a43e1ed29fe3c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a581cd4e3126f17a43e1ed29fe3c4e">&#9670;&nbsp;</a></span>USBD_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBD_process </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB process (Deprecated) </p>
<p >To be continuously called by the user application or USB device thread. Checks for control endpoint transfer activity and invokes relevant callback. Manages suspend and resume states and power management. </p><dl class="section return"><dt>Returns</dt><dd>Non-zero if USB transaction has been processed. </dd></dl>

</div>
</div>
<a id="a16957bd5720ec123867e187a61dd7b59" name="a16957bd5720ec123867e187a61dd7b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16957bd5720ec123867e187a61dd7b59">&#9670;&nbsp;</a></span>USBD_req_get_configuration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBD_req_get_configuration </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles GET_CONFIGURATION request. </p>
<p >Handles the DATA phase of a GET_CONFIGURATION request from host. The application has to respond with SETUP ACK or STALL. The default standard request handler will call this function, if the handler is overridden then the application must call this when this request is received. </p><dl class="section return"><dt>Returns</dt><dd>USBD_OK on success.<br  />
 USBD_ERR_INVALID_PARAMETER if req is invalid. </dd></dl>

</div>
</div>
<a id="a60c02884a863d96c5da88895d6c7ddab" name="a60c02884a863d96c5da88895d6c7ddab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c02884a863d96c5da88895d6c7ddab">&#9670;&nbsp;</a></span>USBD_req_set_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBD_req_set_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b__device__request.html">USB_device_request</a> *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles SET_ADDRESS request. </p>
<p >Places the device in the ADDRESS state. The application has to respond with SETUP ACK or STALL. The default standard request handler will call this function, if the handler is overridden then the application must call this when this request is received. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>USB request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBD_OK on success.<br  />
 USBD_ERR_INVALID_PARAMETER if req is invalid. </dd></dl>

</div>
</div>
<a id="a87a12fee5f06e54d394f52a3281c89b9" name="a87a12fee5f06e54d394f52a3281c89b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a12fee5f06e54d394f52a3281c89b9">&#9670;&nbsp;</a></span>USBD_req_set_configuration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBD_req_set_configuration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b__device__request.html">USB_device_request</a> *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles SET_CONFIGURATION request. </p>
<p >Places the device in the CONFIGURED state or puts it back into the ADDRESS state. The application has to respond with SETUP ACK or STALL. The default standard request handler will call this function, if the handler is overridden then the application must call this when this request is received. TODO: Possible future enhancement may be a method of checking configuration value defined by application. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>USB request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBD_OK on success.<br  />
 USBD_ERR_INVALID_PARAMETER if req is invalid. </dd></dl>

</div>
</div>
<a id="abbe9106a038ff6e7244da1d402546dce" name="abbe9106a038ff6e7244da1d402546dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe9106a038ff6e7244da1d402546dce">&#9670;&nbsp;</a></span>USBD_resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_resume </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume from Suspend. </p>
<p >When USB related events like host resume and host reset are detected, PM irq will be received if it is enabled. The firmware needs to remove the SUSPEND from the PHY by calling this function. </p>

</div>
</div>
<a id="ab044ab14b72587ceb4cc38d00e0bb404" name="ab044ab14b72587ceb4cc38d00e0bb404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab044ab14b72587ceb4cc38d00e0bb404">&#9670;&nbsp;</a></span>USBD_set_remote_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_set_remote_wakeup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set USB remote wakeup feature status. </p>

</div>
</div>
<a id="a6f0075280857bc153c35a279913a60f5" name="a6f0075280857bc153c35a279913a60f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0075280857bc153c35a279913a60f5">&#9670;&nbsp;</a></span>USBD_set_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_set_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbd_8h.html#a21849edc8e9a97fefd204a4875c27c19">USBD_STATE</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set USB state. </p>
<p >Sets the current state of the current USB device. Please refer to section 9.1 of the USB 2.0 spec for more information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>The new state of the current USB device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6570d773f3675683c2b6211fe6a42d19" name="a6570d773f3675683c2b6211fe6a42d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6570d773f3675683c2b6211fe6a42d19">&#9670;&nbsp;</a></span>USBD_set_test_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_set_test_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbd_8h.html#a0b44dddcb8245ddac5409f9f8eb3a993">USBD_TESTMODE_SELECT</a>&#160;</td>
          <td class="paramname"><em>test_selector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USBD_set_test_mode. </p>
<p >To be called to enter into Test Mode. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">test_selector</td><td>The type of test to be performed in the Test Mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3608e7e6c3334d9203f93151424aceb" name="ab3608e7e6c3334d9203f93151424aceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3608e7e6c3334d9203f93151424aceb">&#9670;&nbsp;</a></span>USBD_stall_endpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t USBD_stall_endpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">USBD_ENDPOINT_NUMBER</a>&#160;</td>
          <td class="paramname"><em>ep_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stall endpoint. </p>
<p >Stalls the specified endpoint. The default standard request handler will call this function for a SET_FEATURE endpoint request. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_number</td><td>USB endpoint number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>USBD_OK if successful USBD_ERR_NOT_CONFIGURED if the endpoint is not configured. USBD_ERR_INVALID_PARAMETER if the endpoint number is not allowed. </dd></dl>

</div>
</div>
<a id="ae4198e2c16ae0c3e45d222d441824e86" name="ae4198e2c16ae0c3e45d222d441824e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4198e2c16ae0c3e45d222d441824e86">&#9670;&nbsp;</a></span>USBD_suspend_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_suspend_device </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend USB device. </p>
<p >When device is initialized and no bus activity for certain time, this API can be called to put the USB device to suspend. This API takes the USBD state to USBD_STATE_SUSPENDED </p>

</div>
</div>
<a id="ab47aed0a350136f029ecdfdfcc201448" name="ab47aed0a350136f029ecdfdfcc201448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47aed0a350136f029ecdfdfcc201448">&#9670;&nbsp;</a></span>USBD_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_timer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB timer. </p>
<p >To be called every millisecond from an interrupt handler to provide timeout support for USB device transactions. This will check all pending transfers, decrement timeout values and expire any timed out transactions. </p>

</div>
</div>
<a id="a4238dea9bfd7a98fdd6f018f29a7b067" name="a4238dea9bfd7a98fdd6f018f29a7b067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4238dea9bfd7a98fdd6f018f29a7b067">&#9670;&nbsp;</a></span>USBD_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t USBD_transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">USBD_ENDPOINT_NUMBER</a>&#160;</td>
          <td class="paramname"><em>ep_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer data to/from a non-control USB endpoint. </p>
<p >USB IN or OUT request is implied from the settings of the endpoint passed as a parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_number</td><td>USB endpoint number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Appropriately sized buffer for the transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>For IN transfers, the number of bytes to be sent. For OUT transfers, the maximum number of bytes to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually transferred. USBD_ERR_NOT_CONFIGURED if endpoint is not configured. USBD_ERR_INVALID_PARAMETER if endpoint number not allowed. </dd></dl>

</div>
</div>
<a id="afbe49b688d1767ec00c2e611c76f618b" name="afbe49b688d1767ec00c2e611c76f618b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe49b688d1767ec00c2e611c76f618b">&#9670;&nbsp;</a></span>USBD_transfer_ep0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t USBD_transfer_ep0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbd_8h.html#a43d12225cb06f8331d359e6dcca5c70d">USBD_ENDPOINT_DIR</a>&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>requestLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer data to/from a USB control endpoint. </p>
<p >Endpoint number is asusmed to be zero. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dir</td><td>Control endpoint data direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Appropriately sized buffer for the transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataLength</td><td>For IN transfers, the number of bytes to be sent. For OUT transfers, the maximum number of bytes to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">requestLength</td><td>The number of bytes requested by the host in the wLength field of the SETUP packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually transferred. USBD_ERR_NOT_CONFIGURED if endpoint is not configured. </dd></dl>

</div>
</div>
<a id="ae4485ff25be1ee81ce6e14160426717a" name="ae4485ff25be1ee81ce6e14160426717a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4485ff25be1ee81ce6e14160426717a">&#9670;&nbsp;</a></span>USBD_transfer_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t USBD_transfer_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ft900__usbd_8h.html#ab0d985b035ef563a7379df0f45216cbc">USBD_ENDPOINT_NUMBER</a>&#160;</td>
          <td class="paramname"><em>ep_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer data to/from a non-control USB endpoint with options. </p>
<p >USB IN or OUT request is implied from the settings of the endpoint passed as a parameter. The end-of-packet will not be sent when the data from the buffer parameter is sent. This will allow a follow-on USBD_transfer_ex call to either send more data (with the part parameter non-zero and a correct offset set) or an end-of-packet with part not set. This allows a USB data packet to a non-control endpoint to be formed from multiple calls with data from potentially different places. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_number</td><td>USB endpoint number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Appropriately sized buffer for the transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>For IN transfers, the number of bytes to be sent. For OUT transfers, the maximum number of bytes to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">part</td><td>Signifies that this is a partial transfer. Set one of USBD_TRANSFER_EX_PART_NORMAL or USBD_TRANSFER_EX_PART_NO_SEND. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset (within the current packet) from where to continue for subsequent calls when using partial packets. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually transferred. USBD_ERR_NOT_CONFIGURED if endpoint is not configured. USBD_ERR_INVALID_PARAMETER if endpoint number not allowed. </dd></dl>

</div>
</div>
<a id="ad26051cd0b73ac47f0902caa3e89d56b" name="ad26051cd0b73ac47f0902caa3e89d56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26051cd0b73ac47f0902caa3e89d56b">&#9670;&nbsp;</a></span>USBD_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_wakeup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume signalling for remote wakeup. </p>
<p >Drive resume signalling upstream when remote wakeup is enabled. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 7 2022 14:07:40 for libft900 by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
